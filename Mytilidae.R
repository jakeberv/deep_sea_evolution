#code for downloading sequences from genbank and cleaning up
#example code from 
#http://www.jcsantosresearch.org/Class_2014_Spring_Comparative/pdf/week_2/Jan_13_15_2015_GenBank_part_2.pdf

require(ape)
require(seqinr)
require(plyr)
require(insect)
require(readxl)
require(phytools)
require(Rphylopars)
require(nlme)
require(geiger)
require(ggplot2)
require(gridExtra)
require(olsrr)
require(WGCNA)
require(evomap)


setwd('~/jsb439@cornell.edu/amelia-bivalves')
source(file="/Users/cotinga/jsb439@cornell.edu/Code/deep_sea_evolution/functions.R")

#read in the excel spreadsheet
data<-read_excel('~/jsb439@cornell.edu/amelia-bivalves/bivalves/Mytilidae2.xlsx', sheet="data")

#set up CO1
{

#extract only Mytilidae 
Mytilidae <- data[data$Family=='Mytilidae',]
Mytilidae_CO1_accession_numbers <- Mytilidae$CO1
CO1_accession_numbers <- Mytilidae_CO1_accession_numbers[!is.na(Mytilidae_CO1_accession_numbers)] #filter out NAs
Mytilidae_pruned <- Mytilidae[!is.na(Mytilidae$CO1),] #filter out rows without CO1 accession numbers (for species labels)

# #extract only Solemyidae  (outgroup)
# Solemyidae <- data[data$Family=='Solemyidae',]
# Solemyidae <- Solemyidae[which(Solemyidae$`8.21.18_CO1_Fasta`=='y'),] #filter in those same taxa used as outgroups b4
# Solemyidae_CO1_accession_numbers <- Solemyidae$CO1 #extract only CO1 accession numbers

#extract only Pteriidae  (outgroup)
Pteriidae <- data[data$Family=="Pteriidae",]
Pteriidae <- Pteriidae[!is.na(Pteriidae$CO1),] #filter out rows without CO1 accession numbers (for species labels)
Pteriidae_CO1_accession_numbers <- Pteriidae$CO1 #extract only CO1 accession numbers

#extract only Pinnidae  (outgroup)
Pinnidae <- data[data$Family=="Pinnidae",]
Pinnidae <- Pinnidae[!is.na(Pinnidae$CO1),] #filter out rows without CO1 accession numbers (for species labels)
Pinnidae_CO1_accession_numbers <- Pinnidae$CO1 #extract only CO1 accession numbers

#extract only Ostreidae  (outgroup)
Ostreidae <- data[data$Family=="Ostreidae",]
Ostreidae <- Ostreidae[!is.na(Ostreidae$CO1),] #filter out rows without CO1 accession numbers (for species labels)
Ostreidae_CO1_accession_numbers <- Ostreidae$CO1 #extract only CO1 accession numbers


CO1.L<-c(CO1_accession_numbers, Pteriidae_CO1_accession_numbers, Pinnidae_CO1_accession_numbers, Ostreidae_CO1_accession_numbers)
#test<-capture.output(print(CO1.L))
#read.GenBank(print(CO1.L))
#CO1<-read.GenBank(c(CO1_accession_numbers, Solemyidae_CO1_accession_numbers))

#from https://gist.github.com/sckott/4632735
#slice<- function (input, by =2){
#	starts<-seq(1, length(input), by)
#	tt<- lapply(starts, function(y) input[y:(y+(by-1))])
#	llply(tt, function(x) x[!is.na(x)])
#}

#CO1.L<-slice(CO1.L, by =40)
#CO1<-lapply(CO1.L, read.GenBank, species.names = TRUE)

#CO1<-lapply(CO1.L, read.GenBank, species.names = TRUE)

CO1<-read.GenBank(access.nb=CO1.L, species.names=T, quiet=F)

#must modify to fix if there are more in the future
#CO1 <- insect::join(CO1[[1]],CO1[[2]],CO1[[3]],CO1[[4]])
#test<-insect::join(CO1[[1]],CO1[[2]],CO1[[3]],CO1[[4]])
#attr(test, "species")

SequenceNames<-paste(names(CO1), attr(CO1, "species"), sep ="_CO1_") #generate new vector of taxon IDs

names(CO1) <- SequenceNames #assign new names


#write unaligned fasta out for alignment in MAAFT and then analysis in RAxML
#write.dna(CO1, format='fasta', file='unaligned_1_18_22.fas')
}

## read in the tree generated by IQTREE
{
CO1_ML.unconstrained<-read.tree("/Users/cotinga/jsb439@cornell.edu/amelia-bivalves/bivalves/2022/alltax/unconstrained/unconstrained.treefile")
CO1_ML.constrained<-read.tree("/Users/cotinga/jsb439@cornell.edu/amelia-bivalves/bivalves/2022/alltax/constrained/constrained.treefile")
CO1_ML.constrained.boottrees<-read.tree("/Users/cotinga/jsb439@cornell.edu/amelia-bivalves/bivalves/2022/alltax/constrained_fullboot/constrained.boottrees")
CO1_ML.unconstrained.boottrees<-read.tree("/Users/cotinga/jsb439@cornell.edu/amelia-bivalves/bivalves/2022/alltax/unconstrained_fullboot/partfile.txt.boottrees")

#deep sea only
CO1_ML.unconstrained.deep<-read.tree("/Users/cotinga/jsb439@cornell.edu/amelia-bivalves/bivalves/2022/deepsea/unconstrained/unconstrained.treefile")
CO1_ML.constrained.deep<-read.tree("/Users/cotinga/jsb439@cornell.edu/amelia-bivalves/bivalves/2022/deepsea/constrained/constrained.treefile")

#sort(SequenceNames)==sort(CO1_ML.untrimmed$tip.label)
#sort(SequenceNames)[70]
#sort(CO1_ML$tip.label)[70]

}

#process data
{
#combined data for ingroup and outgorup
data<-rbind(Mytilidae_pruned,Pteriidae, Pinnidae, Ostreidae)
#convert data to data frame
data<-as.data.frame(data)
rownames(data)<-data$`Tip Names`

#checking names matching
#sort(rownames(data))==sort(CO1_ML.constrained$tip.label)
#cbind(sort(rownames(data)), sort(CO1_ML.constrained$tip.label))[72,]
}

#rooting
{
#find the root node and reroot
root.unconstrained<-findMRCA(CO1_ML.unconstrained, tips=rbind(Pteriidae, Pinnidae, Ostreidae)$`Tip Names`) #trimmed
root.constrained<-findMRCA(CO1_ML.constrained, tips=rbind(Pteriidae, Pinnidae, Ostreidae)$`Tip Names`) #trimmed + constrained

root.unconstrained.deep<-findMRCA(CO1_ML.unconstrained.deep, tips=c("AB076912_CO1_Modiolus_nipponicus", "AB076940_CO1_Modiolus_metcalfei", "FJ890501_CO1_Modiolus_modiolus", "KC429094_CO1_Modiolus_rumphii", "KY081298_CO1_Modiolus_auriculatus")) #trimmed
root.constrained.deep<-findMRCA(CO1_ML.constrained.deep, tips=c("AB076912_CO1_Modiolus_nipponicus", "AB076940_CO1_Modiolus_metcalfei", "FJ890501_CO1_Modiolus_modiolus", "KC429094_CO1_Modiolus_rumphii", "KY081298_CO1_Modiolus_auriculatus")) #trimmed + constrained

#reroot on root
tree.unconstrained <- reroot(CO1_ML.unconstrained, node.number=root.unconstrained)
tree.constrained <- reroot(CO1_ML.constrained, node.number=root.constrained)

#reroot on root
tree.unconstrained.deep <- reroot(CO1_ML.unconstrained.deep, node.number=root.unconstrained.deep)
tree.constrained.deep <- reroot(CO1_ML.constrained.deep, node.number=root.constrained.deep)
}


#do I want the constrained tree or the unconstrained tree -- comment to change
#prune outgroups
{
#cut the outgroup tips
prunetree.unconstrained <- drop.tip(tree.unconstrained, tip=rbind(Pteriidae, Pinnidae, Ostreidae)$`Tip Names`)
prunetree.constrained <- drop.tip(tree.constrained, tip=rbind(Pteriidae, Pinnidae, Ostreidae)$`Tip Names`)
prunetree.unconstrained.deep <- drop.tip(tree.unconstrained.deep, tip=c("AB076912_CO1_Modiolus_nipponicus", "AB076940_CO1_Modiolus_metcalfei", "FJ890501_CO1_Modiolus_modiolus", "KC429094_CO1_Modiolus_rumphii", "KY081298_CO1_Modiolus_auriculatus"))
prunetree.constrained.deep <- drop.tip(tree.constrained.deep, tip=c("AB076912_CO1_Modiolus_nipponicus", "AB076940_CO1_Modiolus_metcalfei", "FJ890501_CO1_Modiolus_modiolus", "KC429094_CO1_Modiolus_rumphii", "KY081298_CO1_Modiolus_auriculatus"))
}

# #calculate root to tip paths commented for now
{
# {
# ####
r2t.prunetree.unconstrained<-as.data.frame(diag(vcv.phylo(prunetree.unconstrained)))
r2t.prunetree.constrained<-as.data.frame(diag(vcv.phylo(prunetree.constrained)))
r2t.prunetree.unconstrained.deep<-as.data.frame(diag(vcv.phylo(prunetree.unconstrained.deep)))
r2t.prunetree.constrained.deep<-as.data.frame(diag(vcv.phylo(prunetree.constrained.deep)))
# 
# #checking to see if branch length estimates are different with/without shallow
# #plot(
# #setNames(r2t.prunetree.constrained.deep$`diag(vcv.phylo(prunetree.constrained.deep))`, rownames(r2t.prunetree.constrained.deep)),
# #setNames(r2t.prunetree.constrained$`diag(vcv.phylo(prunetree.constrained))`, rownames(r2t.prunetree.constrained))[rownames(r2t.prunetree.constrained.deep)]
# #)
# #some are a bit different
# }
}

###

plot(prunetree.constrained.deep, cex=0.3, no.margin = T)

#root to tip length from the pruned tree as r2t
#r2t.prunetree<-as.data.frame(diag(vcv.phylo(prunetree)))

#checking constrained vs unconstrained -- virtually the same
# plot(setNames(r2t.prunetree.constrained$`diag(vcv.phylo(prunetree.constrained))`,
#               rownames(r2t.prunetree.constrained))~ 
#   setNames(r2t.prunetree.unconstrained$`diag(vcv.phylo(prunetree.unconstrained))`,
#            rownames(r2t.prunetree.unconstrained))[rownames(r2t.prunetree.constrained)])
# 

#prune out outgroups
#data<-data[!data$Outgroup==1,]

#data processing
{
#reorder the data frame to match r2t
data<-data[rownames(r2t.prunetree.constrained),] #this also prunes out the outgroups from the dataset

#checking names
data.frame(sort(rownames(data)), sort(rownames(r2t.prunetree.constrained)), c(sort(rownames(data)) == sort(rownames(r2t.prunetree.constrained))))


#which tree do we want to use?
prunetree<-prunetree.constrained.deep
#exclude shallow for this first analysis

#get rid of unknown 
remove<-rownames(data[data$Habitat_Mod=='?',])
data <- data[!data$Habitat_Mod=='?',]
prunetree<- drop.tip(prunetree, tip=remove)


#prune out rows with multiple habitat types
#get rid of OF, Vent
remove<-rownames(data[data$Habitat_Mod=='OF, Vent',]) #not being stored
#remove AY275546.1_Idas_washingtonia from data
data <- data[!data$Habitat_Mod=='OF, Vent',]
#remove AY275546.1_Idas_washingtonia from tree
prunetree<- drop.tip(prunetree, tip=remove)


#get rid of vent, seep
remove<-rownames(data[data$Habitat_Mod=='Vent, Seep',])
#remove AB101422_CO1_Bathymodiolus_japonicus, AB101419_CO1_Bathymodiolus_platifrons, AB170054_CO1_Bathymodiolus_aduloides
data <- data[!data$Habitat_Mod=='Vent, Seep',]
#remove AB101422.1_Bathymodiolus_japonicus and AB101419.1_Bathymodiolus_platifrons from data
prunetree<- drop.tip(prunetree, tip=remove)


#get rid of Seep, OF
remove<-rownames(data[data$Habitat_Mod=='Seep, OF',])
#remove AB101422_CO1_Bathymodiolus_japonicus, AB101419_CO1_Bathymodiolus_platifrons, AB170054_CO1_Bathymodiolus_aduloides
data <- data[!data$Habitat_Mod=='Seep, OF',]
#remove AB101422.1_Bathymodiolus_japonicus and AB101419.1_Bathymodiolus_platifrons from data
prunetree<- drop.tip(prunetree, tip=remove)


#this next section is optional
#get rid of shallow
shallow<-rownames(data[data$Habitat_Mod=='Shallow',])
data <- data[!data$Habitat_Mod=='Shallow',]
prunetree.shallow<- drop.tip(prunetree, tip=shallow)
####
#plot(prunetree.shallow, cex=0.25, no.margin=T)


#create version of the unconstrained tree with the same taxon set
#selecting only the deep taxon tree
tree.unconstrained.pruned <- drop.tip(prunetree.unconstrained.deep, tip=CO1_ML.unconstrained.deep$tip.label[!CO1_ML.unconstrained.deep$tip.label  %in% prunetree.shallow$tip.label])
#plot(tree.unconstrained.pruned)
tree.unconstrained.pruned.r2t<-diag(vcv(tree.unconstrained.pruned))[prunetree.shallow$tip.label]

}


#plotting the tree
{
plot(ladderize(tree.unconstrained.pruned), no.margin=T, cex=0.3)

#don't forget to change to shallow prune vs now
tiplabels(frame='circle', pch=16,col=palette()[as.numeric(as.factor(data[tree.unconstrained.pruned$tip.label,]$Habitat_Mod))], cex=0.7)

#add.simmap.legend(leg=unique(as.factor(data[prunetree$tip.label,]$Habitat_Mod)), colors=unique(palette()[as.numeric(as.factor(data[prunetree$tip.label,]$Habitat_Mod))]), fsize=0.8, prompt=T, shape='circle')

add.simmap.legend(leg=as.character(unique(as.factor(data[tree.unconstrained.pruned $tip.label,]$Habitat_Mod))), colors=unique(palette()[as.numeric(as.factor(data[tree.unconstrained.pruned $tip.label,]$Habitat_Mod))]), fsize=0.8, prompt=T, shape='circle')

#constrained tree
plot(ladderize(prunetree.shallow), no.margin=T, cex=0.1)

#don't forget to change to shallow prune vs now
tiplabels(frame='circle', pch=16,col=palette()[as.numeric(as.factor(data[prunetree.shallow $tip.label,]$Habitat_Mod))], cex=0.7)


add.simmap.legend(leg=as.character(unique(as.factor(data[prunetree.shallow $tip.label,]$Habitat_Mod))), colors=unique(palette()[as.numeric(as.factor(data[prunetree.shallow $tip.label,]$Habitat_Mod))]), fsize=0.8, prompt=T, shape='circle')


#Shallow = 'green3'
#Seep = 'red'
#Vent = 'blue'
#OF = 'black'

dev.off()

#end plotting
}


#reorder data to match tree order
data<-data[prunetree.shallow$tip.label,]
#write.csv(data, 'mytilid_data_for_amelia.csv')


#calculate root to tip
{
#experimental section
      
      r2t<-as.data.frame(diag(vcv.phylo(prunetree.shallow)))
      plot(prunetree.shallow, cex=0.4, no.margin=T)
      
      length(data[,1]) #checks how many rows in the data
      prunetree.shallow #check how many tips and nodes
      
      #store habitat data
      x <- data$Habitat_Mod
      names(x) <- rownames(data)
      x<- x[prunetree.shallow$tip.label]
      #names(x) == prunetree.shallow$tip.label
      
      #store r2t data
      y.constrained <- r2t[,1]
      names(y.constrained) <- rownames(r2t)
      y.constrained<- y.constrained[prunetree.shallow$tip.label]
      
      y.unconstrained<-tree.unconstrained.pruned.r2t
      
      #store size data
      size <- as.numeric(data$`Max Shell Size (mm)`)
      names(size) <- rownames(data)
      size<- size[prunetree.shallow$tip.label]
      
      #names(x) == prunetree.shallow$tip.label
      
      
      # data.frame(x,y,size)
      # 
      # plot(log(y)~log(size))
      # summary(lm(y~log(size)))
      # 
      # 
      # #store spreading rate data
      spread<-data$rate_cat
      names(spread)<-rownames(data)
      # 
      tmp<-data.frame(r2t.constrained=y.constrained, r2t.unconstrained=y.unconstrained, habitat=x, size=size, spread=as.factor(spread))

      boxplot(r2t.constrained~spread, data=tmp, varwidth=T)

      #anova(lm(r2t~spread, data=tmp))

      write.csv(tmp, file='r2t_habitat_size_spread.txt', row.names=T)
      # 
      # 
      # #checking names again
      # names(x) == names(y)
      # 
      # #phytools r package anova
      # #uses the raxml tree
      # #nsim is the number of simulations, default is 1000
      # #increasing the number seems to give more power
      # 
      # prunetree.shallow$tip.label


}
    
#plot(log(y.constrained) ~ log(y.unconstrained))

#congruification 
{
#congruification with lorien calibrations (for phylogenetic anova)
lorion <-read.nexus('~/jsb439@cornell.edu/amelia-bivalves/bivalves/BEAST-output/Size.(time).mean.tre')
#lorion <-drop.tip(lorion, tip='ESU_S')

lorion$tip.label<- c("FJ937033_CO1_Terua_arcuatilis", "EU702319_CO1_Gigantidas_crypta", "HF545100_CO1_Idas_iwaotakii", "EU350072_CO1_Adipicola_longissima", "AB170040_CO1_Adipicola_pacifica", "AB170054_CO1_Bathymodiolus_aduloides", "AF456317_CO1_Bathymodiolus_sp._RCV-2003", "AY649795_CO1_Bathymodiolus_azoricus", "FJ890503_CO1_Bathymodiolus_boomerang", "AY275544_CO1_Bathymodiolus_brevior", "AY649798_CO1_Bathymodiolus_brooksi", "AB101422_CO1_Bathymodiolus_japonicus", "GU966637_CO1_Bathymodiolus_manusensis", "AY649801_CO1_Gigantidas_mauritanicus", "AB101419_CO1_Gigantidas_platifrons", "AY649796_CO1_Bathymodiolus_puteoserpentis", "AB170048_CO1_Bathymodiolus_securiformis", "HF545112_CO1_Bathymodiolus_sp._Kikaijima", "HF545125_CO1_Bathymodiolus_sp._Sissano1", "HF545122_CO1_Bathymodiolus_sp._Sissano2", "GU966638_CO1_Gigantidas_taiwanensis", "AY608439_CO1_Gigantidas_tangaroa", "GU966639_CO1_Bathymodiolus_thermophilus", "AB257513_CO1_Benthomodiolus_sp._895-1", "AY275545_CO1_Benthomodiolus_lignocola", "KF611694_CO1_Benthomodiolus_sp._Juan_de_Fuca", "EU702375_CO1_Idas_sp._C_JL-2008", "HF545116_CO1_Idas_sp._ESU_D", "FJ937079_CO1_Idas_sp._E_JL-2009", "FJ937127_CO1_Idas_sp._F_JL-2009", "FJ937161_CO1_Idas_sp._G_JL-2009", "FJ937182_CO1_Idas_sp._I_JL-2009", "FJ937189_CO1_Idas_sp._J_JL-2009", "FJ937193_CO1_Idas_sp._L_JL-2009", "FJ937202_CO1_Idas_sp._M_JL-2009", "FJ937206_CO1_Idas_sp._O_JL-2009", "FJ937213_CO1_Idas_sp._P_JL-2009", "FJ937239_CO1_Idas_sp._R_JL-2009", "HF545117_CO1_Idas_sp._ESU_S", "FJ937283_CO1_Idas_sp._T_JL-2009", "AY649802_CO1_Gigantidas_gladius", "AB257538_CO1_Gigantidas_horikoshii", "HF545119_CO1_Gigantidas_sp._Aitape", "AB257529_CO1_Gigantidas_sp._Ashizuri", "AB257536_CO1_Idas_japonicus", "AY649804_CO1_Idas_macdonaldi", "EF210072_CO1_Idas_sp._SSD-2007", "FJ937271_CO1_Idas_sp._SAL1", "DQ340772_CO1_Idas_sp._SAL3", "HF545124_CO1_Idas_sp._SAL4", "AY275546_CO1_Idas_washingtonia", "AY649803_CO1_Tamu_fisheri", "FJ767936_CO1_Bathymodiolus_sp._NZ3")

#plot(lorion, cex=0.01)

lorion <-force.ultrametric(lorion, method="extend") ##something weird has happened
is.ultrametric(lorion)

#source('~/jsb439@cornell.edu/amelia-bivalves/Congruify.R')
#install.packages("devtools")
#library(devtools)
#install_github("mwpennell/geiger-v2")

tax<-data.frame(row.names=lorion$tip.label, taxonomy= lorion$tip.label)
test<-congruify.phylo(lorion, prunetree.shallow, taxonomy=tax, scale='treePL')
test$phy<-ladderize(test$phy, right=T)
test$phy<-force.ultrametric(test$phy, method='extend')

calibrations<-test$calibrations
calibrations$MRCA<-NULL
calibrations2<-calibrations[,3:4]
calibrations2<-as.data.frame(calibrations2)

#
#tmp<-list()
#for (i in 1:52){
#	tmp[i]<-findMRCA(prunetree.shallow, tips=c(calibrations2[i, #calibrations2[i,2]),type='node')
#}
#errors are generated but this works

#generating calibration frame for chronos
#cals<-data.frame(node=unlist(tmp), age.min=calibrations$MinAge, age.max=calibrations$MaxAge, soft.bounds=rep(FALSE, length(unlist(tmp))))

#prunetree.shallow.time<-chronos(prunetree.shallow, model='relaxed', calibration=cals, lambda=1)

}

#plot(y.constrained ~ y.unconstrained)

####
prunetree.shallow.time<-test$phy
prunetree.shallow.time<-ladderize(prunetree.shallow.time, right=F)

#plot(prunetree.shallow.time, cex=0.5)
#axisPhylo()
#plot.phylo(test$phy, cex=0.01, direction='upwards')
#axisPhylo(side=4)
#par(new=T)
#plot.phylo(prunetree.shallow.time, cex=0.01, no.margin=F, direction='upwards')
#axisPhylo(side=4)

#prunetree.shallow.time<-read.tree('~/jsb439@cornell.edu/amelia-bivalves/approxcalib.tre')
#plot(prunetree.shallow.time, cex=0.5)
#drop<-prunetree.shallow.time$tip.label[!prunetree.shallow.time$tip.label %in% prunetree.shallow$tip.label]
#prunetree.shallow.time <- drop.tip(prunetree.shallow.time, tip = drop)

#plot(prunetree.shallow.time, cex=0.01)

plot(prunetree.shallow.time, cex=0.00001)

#temp writing out data
#export<-cbind(data[names(y.constrained),], y.constrained)
#write.csv(export, file="export_bivalve_data.csv")


#####FOR RUNNING TRAITRATE#####

##setting up three comparisons ### 
#vent vs OF, remove seep, comparison 1
#vent vs seep, remove OF, comparison 2
#seep vs OF, remove vent, comparison 3
{
#set up the genetic datasets
fas<-read.FASTA("/Users/cotinga/jsb439@cornell.edu/amelia-bivalves/bivalves/1_19_22_mafft-pruned.fasta")


#set up comparison 1

#prune out seep
remove1<-rownames(data[data$Habitat_Mod=='Seep',])
#remove seep tips from tree
traitRate1 <- drop.tip(prunetree.shallow.time, tip=remove1)
#write.tree(traitRate1, file="traitRate1.tre")

#create trait dataset
trim1 <- data[!data$Habitat_Mod=='Seep',]
trait1 <- as.numeric(as.factor(trim1$Habitat_Mod))-1
trait1 <- data.frame(trait= setNames(trait1, 
                                   rownames(trim1))[traitRate1$tip.label])
#write.fas(trait1,file="trait1.fas")

#extract the seqs
traitRate1.seq<-fas[traitRate1$tip.label]
#write.fas(traitRate1.seq, file="trait1.seq.fas")



#set up comparison 2

#prune out seep
remove2<-rownames(data[data$Habitat_Mod=='OF',])
#remove seep tips from tree
traitRate2 <- drop.tip(prunetree.shallow.time, tip=remove2)
#write.tree(traitRate2, file="traitRate2.tre")

#create trait dataset
trim2 <- data[!data$Habitat_Mod=='OF',]
trait2 <- as.numeric(as.factor(trim2$Habitat_Mod))-1
trait2<-data.frame(trait= setNames(trait2, 
                                   rownames(trim2))[traitRate2$tip.label])
#write.fas(trait2,file="trait2.fas")

#extract the seqs
traitRate2.seq<-fas[traitRate2$tip.label]
#write.fas(traitRate2.seq, file="trait2.seq.fas")


#set up comparison 3

#prune out vent
remove3<-rownames(data[data$Habitat_Mod=='Vent',])
#remove seep tips from tree
traitRate3 <- drop.tip(prunetree.shallow.time, tip=remove3)
#write.tree(traitRate3, file="traitRate3.tre")


#create trait dataset
trim3 <- data[!data$Habitat_Mod=='Vent',]
trait3 <- as.numeric(as.factor(trim3$Habitat_Mod))-1
trait3<-data.frame(trait= setNames(trait3, 
                                   rownames(trim3))[traitRate3$tip.label])
#write.fas(trait3,file="trait3.fas")

#extract the seqs
traitRate3.seq<-fas[traitRate3$tip.label]
#write.fas(traitRate3.seq, file="trait3.seq.fas")




# 
# traitRate(phy=traitRate1, seq=as.matrix(traitRate1.seq), x=trait1, 
#           exec = "/Applications/Phylogenetics/TraitRateProp_source_20161221/programs/traitRateProp")
# 
# traitRate(phy=traitRate2, seq=as.matrix(traitRate2.seq), x=trait2, 
#           exec = "/Applications/Phylogenetics/TraitRateProp_source_20161221/programs/traitRateProp")
# 
}

#processing traitrate output
{
#read in traitRate results
traitRateRes1<-read.csv(file="/Users/cotinga/jsb439@cornell.edu/amelia-bivalves/traitRate1/TraitRateProp_per_site_report.csv")
traitRateRes1.bayes<-traitRateRes1$bayes_factor
traitRateRes1.bayes[traitRateRes1.bayes < 3] <- -2
traitRateRes1.bayes[traitRateRes1.bayes > 20] <- 20

#append 42 blanks to get it in the right frame
traitRateRes1.bayes<- c(rep(-10,42), traitRateRes1.bayes)


traitRateRes2<-read.csv(file="/Users/cotinga/jsb439@cornell.edu/amelia-bivalves/traitRate2/TraitRateProp_per_site_report.csv")
traitRateRes2.bayes <- traitRateRes2$bayes_factor
traitRateRes2.bayes[traitRateRes2.bayes < 3] <- -2
traitRateRes2.bayes[traitRateRes2.bayes > 20 ] <- 20
#append 42 blanks to get it in the right frame
traitRateRes2.bayes<- c(rep(-10,42), traitRateRes2.bayes)


traitRateRes3<-read.csv(file="/Users/cotinga/jsb439@cornell.edu/amelia-bivalves/traitRate3/TraitRateProp_per_site_report.csv")
traitRateRes3.bayes <- traitRateRes3$bayes_factor
traitRateRes3.bayes[traitRateRes3.bayes < 3] <- -2
traitRateRes3.bayes[traitRateRes3.bayes > 20] <- 20

#append 42 blanks to get it in the right frame
traitRateRes3.bayes<- c(rep(-10,42), traitRateRes3.bayes)

}

#set up simmap visualizations to show the trait distributions
{
traitRate1.simmap<-make.simmap(traitRate1,setNames(trait1$trait, rownames(trait1)),
                               model="ARD", nsim=100)
traitRate1.simmap.obj<-densityMap(traitRate1.simmap,states=levels(setNames(trait1$trait, rownames(trait1)))[2:1],plot=FALSE)

traitRate2.simmap<-make.simmap(traitRate2,setNames(trait2$trait, rownames(trait2)),
                               model="ARD", nsim=100)
traitRate2.simmap.obj<-densityMap(traitRate2.simmap,states=levels(setNames(trait2$trait, rownames(trait2)))[2:1],plot=FALSE)

traitRate3.simmap<-make.simmap(traitRate3,setNames(trait3$trait, rownames(trait3)),
                               model="ARD", nsim=100)
traitRate3.simmap.obj<-densityMap(traitRate3.simmap,states=levels(setNames(trait3$trait, rownames(trait3)))[2:1],plot=FALSE)
}

#code to generate traitRate plots

pdf(file="traitRate_bivalvesCO1.pdf", height=4, width = 8.5)
{
  
  #set up the plotting region for traitrate
  {
    layout.matrix <- matrix(c(1,3,5,2,4,6), nrow = 3, ncol = 2)
    
    layout(mat = layout.matrix,
           heights = c(1, 1, 1), # Heights
           widths = c(0.35, 2.5, 2.5)) # Widths of the two columns
  }
  
#par(mfrow=c(3,1))
#par(mar=c(7.1, 4.1, 7.1, 2.1), xpd=F)

#labels reflect CO1 position in
#NC_056377.1:14737-16287_Mytella_strigata
#plot 1
{
  plot(traitRate1.simmap.obj, legend=F, ftype="off", lwd=1,
       mar=c(1.1, 1, 2, 0.5))
  
  par(mar=c(1, 4.1, 2, 2.1), xpd=F)
  
  plot(traitRateRes1.bayes, 
       ylab="BF Vent vs OF", ylim=c(2,20), 
       bty='n', xlim=c(50,650),
       pch=19,
       col=rep(c("red", "red", "black"), 221),
       xaxt="n", yaxt='n',
       xlab="COX1 position", main="COX1 site position")
  axis(1, at = c(1, 100, 200, 300, 400, 500, 600, 700)-1, 
       labels = rep("", 8))#,c(1, 100, 200, 300, 400, 500, 600, 700))
  axis(2, at = c(3,10,15,20), las=2, cex.axis=0.8)
  #lines(traitRateRes1.bayes, col = "black")
  #barplot(traitRateRes1.bayes, add=T)
  labelPoints(
    x=1:length(traitRateRes1.bayes), y=traitRateRes1.bayes, 
    labels=1:length(traitRateRes1.bayes), 
    cex = 0.6, offs = 0.05, xpd = F, 
    jiggle = 0, protectEdges = F, 
    doPlot = TRUE, col="black")
}

#plot 2
{
  plot(traitRate2.simmap.obj, legend=F, ftype="off", lwd=1,
       mar=c(1.1, 1, 2, 0.5))
  
  par(mar=c(1, 4.1, 2, 2.1), xpd=F)
  
  plot(traitRateRes2.bayes, 
       ylab="BF Vent vs Seep", ylim=c(2,20), 
       bty='n', xlim=c(50,650),
       pch=19,
       col=rep(c("red", "red", "black"), 221),
       xaxt="n", yaxt='n',
       xlab="COX1 position")
  axis(1, at = c(1, 100, 200, 300, 400, 500, 600, 700)-1, 
       labels = rep("", 8))
  axis(2, at = c(3,10,15,20), las=2, cex.axis=0.8)
  labelPoints(
    x=1:length(traitRateRes2.bayes), y=traitRateRes2.bayes, 
    labels=1:length(traitRateRes2.bayes), 
    cex = 0.6, offs = 0.05, xpd = F, 
    jiggle = 0, protectEdges = F, 
    doPlot = TRUE)
  #lines(traitRateRes2.bayes, col = "black")
    
}

#plot 3
{
  plot(traitRate3.simmap.obj, legend=F, ftype="off", lwd=1,
       mar=c(2, 1, 1.5, 0.5))
  
  par(mar=c(2, 4.1, 1, 2.1), xpd=F)    
  plot(traitRateRes3.bayes, 
       ylab="BF Seep vs OF", ylim=c(2,23), 
       bty='n', xlim=c(50,650),
       pch=19,
       col=rep(c("red", "red", "black"), 221),
       xaxt="n", yaxt='n',
       xlab="COX1 position")
  axis(1, at = c(1, 100, 200, 300, 400, 500, 600, 700)-1, 
       labels = c(1, 100, 200, 300, 400, 500, 600, 700))
  axis(2, at = c(3,10,15,20), las=2, cex.axis=0.8)
  labelPoints(
    x=1:length(traitRateRes3.bayes), y=traitRateRes3.bayes, 
    labels=1:length(traitRateRes3.bayes), 
    cex = 0.6, offs = 0.05, xpd = F, 
    jiggle = 0, protectEdges = F, 
    doPlot = TRUE)
  #lines(traitRateRes3.bayes, col = "black")
  
  }

}
dev.off()

#what % of significant sites are first or second codon positions.
mean(c(
1/sum(traitRateRes1.bayes >= 1),
6/sum(traitRateRes2.bayes >= 1),
5/sum(traitRateRes3.bayes >= 1)
))

# ..." most of the sites which are implicated reflect third codon positions"
# "implying rate differences are mostly due to neutral processes"


#####END FOR RUNNING TRAITRATE#####

#boxplot(scale((log(y.constrained)), scale=F)~x, varwidth=T, ylim=c(-.4, .15))

test<-(((terminalLengths(prunetree.shallow)/terminalLengths(tree= prunetree.shallow.time))[prunetree.shallow.time$tip.label]))[names(y.constrained)]

boxplot((log(test))~x, varwidth=T)

boxplot((log(y.constrained))~x, varwidth=T, ylim=c(-.4, .4))
boxplot((log(y.unconstrained))~x, varwidth=T, ylim=c(-.4, .4))
#boxplot(log(pglsdata$size) ~ pglsdata$habitat)
#hist(log(pglsdata$size)[pglsdata$habitat=="OF"])


#boxplot((log(y))~x, varwidth=T)
#boxplot(z_transform(log(y))~x, varwidth=T)


#testing outlier removal
{
anova.data.unconstrained<-data.frame(species= names(y.unconstrained),unconstrained=log(y.unconstrained),habitat=as.factor(x))
library(dplyr)
# Apply the finction to one column
anova.data.unconstrained <- anova.data.unconstrained %>%
  group_by(habitat) %>%
  mutate(unconstrained = remove_outliers(unconstrained))
anova.data.unconstrained<-as.data.frame(anova.data.unconstrained[complete.cases(anova.data.unconstrained),])

#testing outlier removal
anova.data.constrained<-data.frame(species= names(y.constrained),constrained=log(y.constrained),habitat=as.factor(x))
library(dplyr)
# Apply the finction to one column
anova.data.constrained <- anova.data.constrained %>%
  group_by(habitat) %>%
  mutate(constrained = remove_outliers(constrained))
anova.data.constrained<-as.data.frame(anova.data.constrained[complete.cases(anova.data.constrained),])
}
#prunetree.constrained.time$tip.label[!prunetree.constrained.time$tip.label %in% anova.data.unconstrained$species]

boxplot(exp(anova.data.unconstrained$unconstrained)~anova.data.unconstrained$habitat)
boxplot(anova.data.constrained$constrained~anova.data.constrained$habitat)

#restore the tree
prunetree.constrained.time<-prunetree.shallow.time
prunetree.constrained.time.outlier.uncon<-drop.tip(prunetree.constrained.time,  prunetree.constrained.time$tip.label[!prunetree.constrained.time$tip.label %in% anova.data.unconstrained$species])
prunetree.constrained.time.outlier.con<-drop.tip(prunetree.constrained.time,  prunetree.constrained.time$tip.label[!prunetree.constrained.time$tip.label %in% anova.data.constrained$species])

#uses the 'time calibrated tree' 
#run phylogenetic anovas
{
  phyl.aov.constrained <- phylANOVA(prunetree.constrained.time, x = x, y = log(y.constrained), nsim=10000, posthoc=T, p.adj = 'BH')

  phyl.aov.unconstrained <- phylANOVA(prunetree.constrained.time, x = x, y = log(y.unconstrained), nsim=10000, posthoc=T, p.adj = 'BH')
  
  phyl.aov.unconstrained.outlier <- phylANOVA(prunetree.constrained.time.outlier.uncon, x = setNames(anova.data.unconstrained$habitat, anova.data.unconstrained$species), y = (setNames(anova.data.unconstrained$unconstrained, anova.data.unconstrained$species)), nsim=10000, posthoc=T)
  
  phyl.aov.constrained.outlier <- phylANOVA(prunetree.constrained.time.outlier.con, x = setNames(anova.data.constrained$habitat, anova.data.constrained$species), y = (setNames(anova.data.constrained$constrained, anova.data.constrained$species)), nsim=10000, posthoc=T)
  
  #phyl.aov.unconstrained.alt <- phylANOVA(prunetree.constrained.time, x = x.unconstrained, y = log(y.unconstrained), nsim=10000, posthoc=T)
  
  #phyl.aov.unconstrained.alt <- phylANOVA(prunetree.unconstrained.time, x = x, y = log(y.unconstrained), nsim=10000, posthoc=T)
  
  phyl.aov.constrained
  phyl.aov.unconstrained
  #phyl.aov.unconstrained.alt 
  #phyl.aov.unconstrained.alt2
  
}

#phylogenetic anova from geiger r package
#run overall anova
{
  x.unconstrained.factor<-as.factor(x) #this functions needs x (the groups) to be a factor, 
  x.constrained.factor<-as.factor(x) #this functions needs x (the groups) to be a factor, 
  
  
  #using 'time calibrated tree'
  phyl.aov.geiger<-aov.phylo(log(y.constrained)~ x.constrained.factor, prunetree.constrained.time, nsim=10000)
  summary(phyl.aov.geiger)
  attr(phyl.aov.geiger, 'summary')
  
  
  #using 'time calibrated tree'
  phyl.aov.geiger<-aov.phylo(log(y.unconstrained)~ x.constrained.factor, prunetree.constrained.time, nsim=10000)
  summary(phyl.aov.geiger)
  attr(phyl.aov.geiger, 'summary')
  
  #phyl.aov.geiger<-aov.phylo(y.constrained~x.constrained.factor, prunetree.constrained, nsim=10000)
}


#testFitchBeintema(prunetree.constrained.deep)
#checking for node density artifact
path_lengths <- diag(vcv(prunetree.constrained.deep))
node_paths <- nodepath(prunetree.constrained.deep)
node_counts <- sapply(node_paths, length) - 1

node_data <- data.frame(
  NodeCounts = node_counts,  # x variable (speciation events from root)
  TotalPathLength = path_lengths  # y variable (genetic distance to root)
)

plot(node_data$TotalPathLength ~ node_data$NodeCounts)
abline(lm(node_data$TotalPathLength ~ node_data$NodeCounts))
summary(lm(node_data$TotalPathLength ~ node_data$NodeCounts))

# Call:
#   lm(formula = node_data$TotalPathLength ~ node_data$NodeCounts)
# 
# Residuals:
#   Min       1Q   Median       3Q      Max 
# -0.31179 -0.09642 -0.04230  0.08771  0.30750 
# 
# Coefficients:
#   Estimate Std. Error t value Pr(>|t|)    
# (Intercept)           0.890898   0.041145  21.653   <2e-16 ***
#   node_data$NodeCounts -0.003354   0.003539  -0.948    0.345    
# ---
#   Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
# 
# Residual standard error: 0.1281 on 106 degrees of freedom
# Multiple R-squared:  0.008401,	Adjusted R-squared:  -0.0009537 
# F-statistic: 0.8981 on 1 and 106 DF,  p-value: 0.3455



#testFitchBeintema(prunetree.unconstrained)
#testFitchBeintemaNLME(prunetree.unconstrained)



# plot(prunetree.shallow.time)
# #uses the 'time calibrated tree' 
# phyl.aov <- phylANOVA(prunetree.shallow.time, x = x, y = log(y), nsim=10000, posthoc=T)
# phyl.aov


# 
# #try looping through randomized group assignments
# nullp<-list()
# 
# for(i in 1:1000){
# 	set.seed(i)
# 	tmp<-as.data.frame(x)
# 	tmp$random<-tmp[,1]
# 	tmp$random<-sample(tmp$random)
# 	tmp$x <- NULL
# 	tmp<-tmp$random
# 	names(tmp)<-names(x.factor)
# 	phyl.aov.geiger<-aov.phylo(y~tmp, prunetree.shallow.time, nsim=100)
# 	nullp[i]<-attr(phyl.aov.geiger, 'summary')$`Pr(>F) given phy`[1]
# }
# 
# nullp<-unlist(nullp)
# hist(nullp, breaks=20) #, ylim=c(0,60)
# abline(v=0.05, col='red')
# 
# 
# #post hoc test
# require(multcomp)
# multCompTukey <- glht(phyl.aov.geiger, linfct = mcp(group = "Tukey"))
# summary(multCompTukey) #this outputs the p alues for each comparison
# #fix(aov.phylo)

#running the generalized least squares version instead of anova (but it's the same thing)
library(ape)
library(nlme)
library(geiger)

pglsdata <-data.frame(species=y.constrained, r2t=y.constrained, habitat=(x), size=size, spread=spread, r2t.unconstrained=tree.unconstrained.pruned.r2t)
pglsdata$species<-rownames(pglsdata)
pglsdata<-pglsdata[order(pglsdata$habitat),] #sort by habitat
pglsdata$r2t.log<-log(pglsdata$r2t)
pglsdata$r2t.log.unconstrained<-log(pglsdata$r2t.unconstrained)
pglsdata$size.log<-log(pglsdata$size)
#sort by tree labels
pglsdata<-pglsdata[prunetree.constrained.time$tip.label,]

#add colors
pglsdata$cols <- pglsdata$habitat
pglsdata$cols[pglsdata$cols=="Seep"]<-"#CAE3FC"#"#ece7f2"#"#1A48DC"#"#a1dab4"#"blue"
pglsdata$cols[pglsdata$cols=="OF"]<-  "#007AC1"#"#2b8cbe"#1BD7DE"#"#225ea8"#"lightblue"
pglsdata$cols[pglsdata$cols=="Vent"]<-"#00BCDF"#"#a6bddb"#42B649"#"#41b6c4"#grey"
# 
#add pch indicators for cases where size is missing
pglsdata$pch <- ifelse(is.na(pglsdata$size),  23 , 21)

#plot(pglsdata$r2t ~ pglsdata$r2t.unconstrained)

#fill in missing sizes with BM
size_recon<-pglsdata[,c("species", "size")]
size_recon$size<-log(size_recon$size)
size_recon.bm<-phylopars(trait_data=size_recon, tree=prunetree.constrained.time, model = 'BM')
size_recon.ou<-phylopars(trait_data=size_recon, tree=prunetree.constrained.time, model = 'OU')

AIC(size_recon.bm)
AIC(size_recon.ou)

size_recon<-phylopars(trait_data=size_recon, tree=prunetree.constrained.time)$anc_recon
size_recon<-size_recon[1:length(prunetree.constrained.time$tip.label)]
size_recon<-setNames(size_recon, prunetree.constrained.time$tip.label)
size_recon<-exp(size_recon)

bmvou<-lm(size_recon.bm$anc_recon[1:length(prunetree.constrained.time$tip.label)][is.na(pglsdata$size)] ~ size_recon.ou$anc_recon[1:length(prunetree.constrained.time$tip.label)][is.na(pglsdata$size)])
cor(size_recon.bm$anc_recon[1:length(prunetree.constrained.time$tip.label)][is.na(pglsdata$size)], size_recon.ou$anc_recon[1:length(prunetree.constrained.time$tip.label)][is.na(pglsdata$size)])
plot(size_recon.bm$anc_recon[1:length(prunetree.constrained.time$tip.label)][is.na(pglsdata$size)] ~ size_recon.ou$anc_recon[1:length(prunetree.constrained.time$tip.label)][is.na(pglsdata$size)])

#write.table(pglsdata, file = 'mytilid.txt', sep = ',', quote = F)
##possibly redo with OU size model

#write output
recon_output<-data.frame(size = size_recon.bm$anc_recon[1:length(prunetree.constrained.time$tip.label)], var = size_recon.bm$anc_var[1:length(prunetree.constrained.time$tip.label)])
#estimate_mean_ci(means=recon_output$size, variances = recon_output$var, sample_size = 10)
rownames(recon_output) <- prunetree.constrained.time$tip.label
recon_output$var[recon_output$var == 0] <- NA #replace zeros with NA
#write.table(recon_output, file='mytilid_size.txt', quote = F, sep = '\t', row.names = T, col.names = T)


#colors for OF, Seep, vent, in this order
#pglsdata$cols <- c(rep('blue', 47), rep('lightblue',26), rep('grey', 23))
#pglsdata$reorder <- c(rep(1, 47), rep(3,26), rep(2, 23))
#pglsdata<-pglsdata[order(pglsdata$reorder),] #sort by new order
#pglsdata$reorder <- NULL #clean

# #pglsfit <-gls(r2t~habitat, correlation=corPagel(1, prunetree.shallow.time, fixed=F),data=pglsdata, method='ML')
# require(nlme)
# pglsfit <-gls(r2t.log ~ habitat, correlation=corBrownian(phy=prunetree.shallow.time),data=pglsdata)
# summary(pglsfit)
# 
# 
# require(phylolm)
# 
# pglsfit<- phylolm(setNames(log(pglsdata$r2t), pglsdata$species) ~ setNames(pglsdata$habitat, pglsdata$species), phy=prunetree.shallow.time, boot=100, model="BM")
# summary(pglsfit)
# 
# pglsfit<- phylolm(setNames(log(pglsdata$r2t), pglsdata$species) ~ setNames(pglsdata$habitat, pglsdata$species) + log(size_recon) , phy=prunetree.shallow.time, boot=100, model="BM")
# summary(pglsfit)
# 
# 
# pglsfit<- phylolm(setNames(log(pglsdata$r2t), pglsdata$species) ~ log(size_recon), phy=prunetree.shallow.time, boot=100, model="BM")
# summary(pglsfit)
# 
# 
# pglsfit<- phylolm(setNames(log(pglsdata$r2t), pglsdata$species) ~ 1, phy=prunetree.shallow.time, boot=100, model="BM")
# summary(pglsfit)
# 
# 
# 
# require(Rphylopars)
# tmp<-phylopars.lm(r2t ~  size, tree=prunetree.shallow.time, trait_data=pglsdata)
# 
# tmp
# summary(tmp)
# anova(tmp)
# 
# #AIC(lm(r2t~habitat, data=pglsdata))
# 
# tmp<-phylopars.lm(size ~ habitat, tree=prunetree.shallow.time, trait_data=pglsdata, model='BM')
# summary(tmp)
# anova(tmp)
# 
# tmp<-phylopars.lm(r2t ~ log(size), tree=prunetree.shallow.time, trait_data=pglsdata, model='OU')
# summary(tmp)
# anova(tmp)
# 
# 
# #tmp<-phylopars.lm(r2t ~ spread, tree=prunetree.shallow.time, trait_data=pglsdata, model='BM')
# #summary(tmp)
# #anova(tmp)
# 
# 
# #### Multiple comparisons procedures
# #http://rstudio-pubs-static.s3.amazonaws.com/13472_0daab9a778f24d3dbf38d808952455ce.html
# 
# ## Error: no 'model.matrix' method for 'model' found!
# ## Run the following lines. These introduce methods for 'gls' objects.
# model.matrix.gls <- function(object, ...) {
#   model.matrix(terms(object), data = getData(object), ...)
# }
# model.frame.gls <- function(object, ...) {
#   model.frame(formula(object), data = getData(object), ...)
# }
# terms.gls <- function(object, ...) {
#   terms(model.frame(object), ...)
# }
# # The line below gives pairwise comparisons now.  Note that the above
# # performs t-tests for all pairwise differences.
# 
# #.1 means the raxml tree
# #.2 means the time calibrated tree
# 
# #post hoc test
# multCompTukey <- glht(pglsfit, linfct = mcp(habitat = "Tukey"))
# summary(multCompTukey) #this outputs the p alues for each comparison
# 
# #different methods to correct for multiple hypothesis testing
# summary(multCompTukey)
# summary(multCompTukey, test = univariate())
# summary(multCompTukey, test = adjusted("Shaffer"))
# summary(multCompTukey, test = adjusted("Westfall"))
# summary(multCompTukey, test = adjusted("free"))
# summary(multCompTukey, test = adjusted("holm"))


#a<-pglsdata[pglsdata$habitat=='Seep',]
#a[order(a$r2t, decreasing=T),]



#######
#stochastic character mapping

{
habitat<-as.character(pglsdata$habitat)
names(habitat)<-rownames(pglsdata)

#setting up node labels
cols<-setNames(palette()[1:length(unique(habitat))],sort(unique(habitat)))

#modify colors to custom choices
cols[2]<-"#CAE3FC"#"#ece7f2"#1A48DC"#"#a1dab4"#"blue"#<- "blue"
cols[1]<-"#007AC1"#"#2b8cbe"#1BD7DE"#"#225ea8"#"lightblue"#<-"lightblue"
cols[3]<-"#00BCDF"#"#a6bddb"#42B649"#"#41b6c4"#grey"#<-"grey"
  
  
  
#plot(bind.tip(prunetree.shallow.time, tip.label="ROOT", edge.length=0.001, where=100, position=0))

#stochastic character1 map with custom model
#TimeTree.simmap.habitat<-make.simmap(bind.tip(prunetree.shallow.time, tip.label="ROOT", edge.length=0.1, where=100, position=0), 
#                                     c(habitat, ROOT="OF"), model='ARD', nsim=1000, message=T, type='discrete')#, pi=c(1,0,0))

TimeTree.simmap.habitat<-make.simmap(prunetree.shallow.time, habitat, model='ARD', nsim=1000, message=T, type='discrete', pi="fitzjohn")#, pi=c(1,0,0))

TimeTree.simmap.habitat.drop<-TimeTree.simmap.habitat#pbmcapply:::pbmclapply(TimeTree.simmap.habitat, drop.tip.simmap, tip="ROOT")
#oldClass(TimeTree.simmap.habitat.drop)<-class(TimeTree.simmap.habitat)

ARD.fit<-fitMk(prunetree.shallow.time, x=habitat, model='ARD')
AIC(ARD.fit)

dd<-density(TimeTree.simmap.habitat)
plot(dd)
par(new=T)
par(mfrow=c(1,1),oma=c(9,9,9,9))
plot(ARD.fit, show.zeros=F, cex.main=1, cex.traits=0.6, cex.rates=0.6)


#posterior summary of stochastic mapping
pd.ARD<- summary(TimeTree.simmap.habitat, plot=F)

#move the node label
tmp<-pd.ARD$ace#[-198,]

#generate PDF plot
#start plotting
# 
# h<-max(nodeHeights(TimeTree.simmap.habitat[[1]]))
# #plotTree(TimeTree.simmap.habitat[[1]],plot=FALSE)
# obj<-geo.legend(alpha=0.3,cex=1.2,plot=FALSE)
# obj$leg<-h-obj$leg
# plotSimmap(TimeTree.simmap.habitat[[1]], cols, fsize=0.35, ftype='i', lwd=2.5, direction='rightwards',ylim=c(-0.25*Ntip(TimeTree.simmap.habitat[[1]]),Ntip(TimeTree.simmap.habitat[[1]])))
# #geo.legend(leg=obj$leg,colors=obj$colors,cex=1.2, alpha=0.2)
# par(new=T)
}

#plot SIMMAP - constrained BLs
{
  pdf(file = "bivalve.simmap_constrainedBLs.pdf",
      width = 4,
      height = 8)
  
  #plotSimmap(TimeTree.simmap.habitat[[1]], cols, fsize=0.35, ftype='i', lwd=2.5, direction='rightwards')#,ylim=c(-0.25*Ntip(TimeTree.simmap.habitat[[1]]),Ntip(TimeTree.simmap.habitat[[1]])))
  #plotSimmap(TimeTree.simmap.habitat[[1]], cols, fsize=0.35, ftype='i', lwd=2.5, direction='rightwards')#,ylim=c(-0.25*Ntip(TimeTree.simmap.habitat[[1]]),Ntip(TimeTree.simmap.habitat[[1]])))
  
  #conmap<-contMap(tree = as.phylo(TimeTree.simmap.habitat.drop[[1]]), x = setNames((pglsdata$r2t.log), rownames(pglsdata)), plot=F)
  #get rate estimates
  #anc_rates<-getRates(trees=c(TimeTree.simmap.habitat.drop[[1]], prunetree.shallow))
  anc_sub_site <-
    get_matched_edgelengths(trees = c(as.phylo(TimeTree.simmap.habitat.drop[[1]]), prunetree.shallow))[, 2]
  
  tiprates<-get_matched_edgelengths(trees = c(as.phylo(TimeTree.simmap.habitat.drop[[1]]), prunetree.shallow))
  tiprates<-tiprates[,2]/tiprates[,1]
  
  #tiprates2<-terminalLengths(prunetree.shallow)[TimeTree.simmap.habitat.drop[[1]]$tip.label]/terminalLengths(TimeTree.simmap.habitat.drop[[1]])
  #tiprates seem correct
  
#trying to get the internal branch lengths from the phylogram to plot inside the contmap
#not working currently
#  {#plot(prunetree.shallow, cex=0.5)
# # nodelabels(node =
# #              node_indices_edge(tree = prunetree.shallow, edges = c(1:length(prunetree.shallow$edge.length)))[!
# #              node_indices_edge(tree = prunetree.shallow, edges = c(1:length(prunetree.shallow$edge.length))) %in% 1:99]
# #          )
# 
#  a<-setNames(
#    prunetree.shallow$edge.length,
#    node_indices_edge(tree = prunetree.shallow, edges = c(
#      1:length(prunetree.shallow$edge.length)
#    )))
#  a<-a[!as.numeric(names(a)) %in% 1:99]
#  a<-setNames(a, match_nodes(t1=prunetree.shallow, t2=TimeTree.simmap.habitat.drop[[1]])[,2][-1])
#  
# conmap <-
#     contMap(
#       tree = as.phylo(TimeTree.simmap.habitat.drop[[1]]),
#       x =
#         terminalLengths(prunetree.shallow),
#         plot = F, method='user',
#       anc.states = a)
# }

conmap <-
  contMap(
    tree = as.phylo(TimeTree.simmap.habitat.drop[[1]]),
    x = (anc_sub_site[1:99]),
    plot = F, method='user',
    anc.states = (anc_sub_site[-c(1:99)]))

#conmap<-setMap(conmap,c("white","#FFFFB2","#FECC5C","#FD8D3C","#E31A1C"))
conmap <-
  setMap(
    conmap,
    #rev(c(viridis::viridis(8)))[-1],
    c(
      "#f0f0f0",
      "#d9d9d9",
      "#bdbdbd",
      "#969696",
      "#737373",
      "#525252",
      "#252525",
      "#000000"
    ),
    bias = 1.35,
    interpolate = c("spline")
  )

 tree<-as.phylo(TimeTree.simmap.habitat.drop[[1]])
# dotTree(tree,habitat,colors=cols,lwd=3.5,fsize=0.35, ftype='i', sig=2)
# par(fg="transparent")
# 
# plot(conmap$tree,add=TRUE,lwd=3.5,colors=conmap$cols,
#      ylim=c(-1/25*Ntip(tree),Ntip(tree)),offset=1.7)
# 
# par(fg="black")
# 
# add.color.bar(0.3*max(nodeHeights(tree)),conmap$cols,title="rate",
#               lims=conmap$lims,digits=3,prompt=FALSE,x=0.3*max(nodeHeights(conmap)),
#               y=0.4*(1+par()$usr[3]),lwd=4,fsize=1,subtitle="")


 #layout(matrix(c(1,2),1,2),widths=c(0.7,0.3))
 
 plot(
   conmap,
   outline = F,
   fsize = 0.35,
   ftype = 'i',
   lwd = 3.0,
   sig = 3,
   offset = 0.75,
   leg.txt="scaled rate"
 )
 
 axisPhylo(pos=-10, cex.axis=0.5)
 
 # points(
 #   x = rep(max(nodeHeights(tree)) + 2, Ntip(tree)),
 #   y = seq(1, Ntip(tree), length.out = Ntip(tree)),
 #   pch = 21,
 #   bg = pglsdata[conmap$tree$tip.label, ]$cols,
 #   lwd = 0.5
 # )
 #-1/(Ntip(tree))*Ntip(tree)
 #add node labels
 par(lwd = 0.1)

 #relabel to get correct node assignments

 # rownames(tmp) <-
 #   c(matchNodes(tr1 = prunetree.shallow.time, tr2 = conmap$tree)[, 2],
 #     rownames(tmp)[c(Ntip(tree):length(rownames(tmp)))])
 # tmp$names<-rownames(tmp)
 #
 
 #dispRity::tree.age(as.phylo(conmap$tree))[-c(1:99),][,1] > 1
 #tmp[c(dispRity::tree.age(as.phylo(conmap$tree))[-c(1:99),][,1] > 1),]
 
 
 #plot(tree,cex=0.1)

 
 # nodelabels(node = as.numeric(rownames(tmp)[which(c(dispRity::tree.age(as.phylo(conmap$tree))[-c(1:99),][,1] > 1))]),
 #   pie = tmp[as.numeric(rownames(tmp)[which(c(dispRity::tree.age(as.phylo(conmap$tree))[-c(1:99),][,1] > 1))])-99],
 #   piecol = scales::alpha(cols, 1.0),
 #   prompt = FALSE,
 #   cex = 0.6
 # )
 
 nodelabels(#node = as.numeric(rownames(tmp)[which(c(dispRity::tree.age(as.phylo(conmap$tree))[-c(1:99),][,1] > 1))]),
            pie = tmp,#[as.numeric(rownames(tmp)[which(c(dispRity::tree.age(as.phylo(conmap$tree))[-c(1:99),][,1] > 1))])-99],
            piecol = scales::alpha(cols, 1.0),
            prompt = FALSE,
            cex = 0.6
 )
 
 tiplabels(
   pie = tmp[conmap$tree$tip.label,],
   piecol = scales::alpha(cols, 0.85),
   prompt = FALSE,
   cex = 0.3,
   offset=3.25
 )
 
 
 # barplot(rev(r2t.prunetree.constrained.deep[conmap$tree$tip.label, ]), horiz =
 #           T, ylim=c(11, 99))
 
 
 # plotTree.barplot(conmap$tree,log(setNames(r2t.prunetree.constrained.deep[conmap$tree$tip.label,], conmap$tree$tip.label)),
 #                  args.plotTree=list(plot=FALSE),
 #                  args.barplot=list(xlab = expression(paste("tip s/s/Ma"))),
 #                  add=TRUE,ylim=c(3, 161),cex.lab=0.9,cex.axis=0.9)

 # plotTree.barplot(conmap$tree,tiprates[conmap$tree$tip.label],
 #                  args.plotTree=list(plot=FALSE),
 #                  args.barplot=list(xlab = expression(paste("tip s/s/Ma"))),
 #                  add=TRUE,ylim=c(3, 161),cex.lab=0.9,cex.axis=0.9)

# #extract tip states
# tipcols<-pglsdata[prunetree.shallow.time$tip.label,]$cols
# 
# #add tip labels # can only be executed after pars recon for this sectino
# tiplabels(pch=20, col=tipcols, cex=0.8)

#add legend
#add.simmap.legend(colors=cols,fsize=0.75, x=15, y=80, prompt=F, shape="circle", cex=2)

legend(x=12, y=80, legend = names(cols)[c(1,3,2)], pt.bg=cols[c(1,3,2)], pch=21, cex=1, pt.cex=2, bty='n')

dev.off()
}

# #plot SIMMAP - unconstrained BLs -- need to update to reflect the code for constrained bl plotitng
# {
#   pdf(file="bivalve.simmap_unconstrainedBLs.pdf", width=4, height=8)
#   
#   #plotSimmap(TimeTree.simmap.habitat[[1]], cols, fsize=0.35, ftype='i', lwd=2.5, direction='rightwards')#,ylim=c(-0.25*Ntip(TimeTree.simmap.habitat[[1]]),Ntip(TimeTree.simmap.habitat[[1]])))
#   #plotSimmap(TimeTree.simmap.habitat[[1]], cols, fsize=0.35, ftype='i', lwd=2.5, direction='rightwards')#,ylim=c(-0.25*Ntip(TimeTree.simmap.habitat[[1]]),Ntip(TimeTree.simmap.habitat[[1]])))
#   
#   conmap<-contMap(tree = as.phylo(TimeTree.simmap.habitat.drop[[1]]), x = setNames(log(pglsdata$r2t.unconstrained), rownames(pglsdata)), plot=F)
#   #conmap<-setMap(conmap,c("white","#FFFFB2","#FECC5C","#FD8D3C","#E31A1C"))
#   conmap<-setMap(conmap,c("white","black"))
#   
#   plot(conmap, outline=F, fsize=0.35, ftype='i', lwd=2.5, sig=2)
#   #add node labels
#   par(lwd=0.2)
#   #nodelabels(pie=pd.ARD$ace, piecol=cols, prompt=FALSE, cex= 0.5)
#   nodelabels(pie=tmp, piecol=cols, prompt=FALSE, cex= 0.5)
#   
#   # #extract tip states
#   # tipcols<-pglsdata[prunetree.shallow.time$tip.label,]$cols
#   # 
#   # #add tip labels # can only be executed after pars recon for this sectino
#   # tiplabels(pch=20, col=tipcols, cex=0.8)
#   
#   #add legend
#   add.simmap.legend(colors=cols,fsize=0.8, x=15, y=80, prompt=F)
#   
#   dev.off()
# }


#set up phylomorphospace

#some plotting
o<-ordered(pglsdata$habitat, levels=c('OF', 'Vent', 'Seep'))
boxplot(r2t.log~o,data =pglsdata, notch=F)
#boxplot(x=pglsdata[pglsdata$habitat=='OF',]$r2t, y=pglsdata[pglsdata$habitat=='Vent',]$r2t)


#plotting phylomorphospace - constrained
{
tmp_nodecounts<-unlist(lapply(setNames(nodepath(prunetree.shallow.time), prunetree.shallow.time$tip.label), length))[prunetree.shallow.time$tip.label]
Z<-cbind(as.matrix(phylopars(cbind(pglsdata[1],log(pglsdata[4])),prunetree.shallow.time)$anc_recon[1:99,]), tmp_nodecounts[prunetree.shallow.time$tip.label]) #,tiprates[prunetree.shallow.time$tip.label]
#Z$r2t<-pglsdata[2]
Z<-merge(Z, as.data.frame(pglsdata[7]), by='row.names', all=TRUE)
colnames(Z)<- c('species', 'log.size','nodes','log.r2t')
rownames(Z)<- Z$species
Z$species<-NULL
Z<- Z[rownames(pglsdata),]
Z.names<-Z
Z.names$species <- rownames(Z.names)

pdf(file="bivalve.phylomorphospace_constrained_bls.pdf", width=6, height=7)
phylomorphospace(prunetree.shallow.time, X=Z[,c(-2)], label='off', ylim=c(-0.55,0.15), xlim=c(1.5,6),node.size=c(0.0000,0), lwd=0.35, bty='n', ylab="log(r2t)",xlab="log(size)", fsize=0.5)#, control=c(col.edge='white'))

title(main='bivalve phylomorphospace')
#par(new=T)
#plot(r2t.log~log(size), col = pglsdata$cols, data = pglsdata, pch=16, ylim=c(-0.55,0.15), xlim=c(1.5,6), bty='n', xaxt='n', yaxt='n', ylab="", xlab="")
points(log.r2t~log.size, bg = scales::alpha(pglsdata$cols, 0.95), data = Z, pch=pglsdata$pch, lwd=1, cex=1.25)  ## fix here

#points(r2t~`log(size)`, col = "black", data = Z[which(is.na(pglsdata[4]$size)),], pch=19, lwd=0.5, cex=0.5)
#points(r2t~`log(size)`, col = "black", data = Z, pch=19, lwd=0.5, cex=0.15)


#add the bootstrap lines
# for(i in c(1:2)) {
#   cc <- (model$bootconfint95[i,])
#   abline(a=cc[1], b=cc[2], lwd=1, col="red")
#   #curve(plogis(cc[1]+cc[2]*x),col=make.transparent(palette.colors(palette = "Okabe-Ito")[2], 0.25),add=TRUE, lwd=0.25, col='red')
# }

model<-gls(log.r2t ~ log.size, correlation = corBrownian(phy = prunetree.shallow.time, form = ~species), data = Z.names, method = "ML")
model.int<-gls(log.r2t ~ 1, correlation = corBrownian(phy = prunetree.shallow.time, form = ~species), data = Z.names, method = "ML")

abline(model, col=make.transparent('black',1), lwd=4, lty=2)
pGLS_ci<-gls.ci(Z$log.r2t,Z$log.size,vcv(prunetree.shallow.time))
lines(pGLS_ci$CI.plot$X,pGLS_ci$CI.plot$Lower2.5,lty=2)
lines(pGLS_ci$CI.plot$X,pGLS_ci$CI.plot$Upper2.5,lty=2)


#pGLS_pi<-gls.pi(Z$log.r2t,Z$log.size,vcv(prunetree.shallow.time),1000)
#lines(pGLS_pi$PI.plot$X,pGLS_pi$PI.plot$Lower2.5,lty=3)
#lines(pGLS_pi$PI.plot$X,pGLS_pi$PI.plot$Upper2.5,lty=3)

#abline(lm(r2t.log~log(size_recon), data = pglsdata), lwd=2, lty=1, col=make.transparent("red", 0.5))
#model<-phylopars.lm(r2t.log ~ log(size), tree=prunetree.shallow.time, trait_data=pglsdata, model='BM')
#abline(model, col=make.transparent('black',1), lwd=4, lty=2)

#summary(phylopars.lm(r2t.log ~ log(size), tree=prunetree.shallow.time, trait_data=pglsdata, model='BM'))

#summary(lm(log(r2t)~log(size), data =pglsdata))
legend('topright', title='habitat type', c('Organic fall','Seep', 'Vent')[c(1,3,2)], col=cols[c(1,3,2)], pch=16, bty='n', cex=1)

#legend('top', text.col='red', legend=c('PGLS p~0.97'), cex=0.85, box.lwd=0.5) 
#legend('topleft', text.col='black', legend=c('LM R^2=0.328, p<<0.05'), cex=0.85, box.lwd=0.5)
dev.off()

}


tmp<-phylolm::phylolm(log.r2t ~ log.size, data = Z.names[,c(-4)],  phy= prunetree.constrained.time, boot=1000)
plot(tmp$residuals ~ log.size, data = Z.names[,c(-4)])
plot(tmp)
qqnorm(model,abline = c(0,1))
predictmeans::residplot(model)
tmp$bootconfint95

#trying with only taxa with non-missing data
tmp<-phylolm::phylolm(r2t.log ~ size.log, data = pglsdata,  phy= prunetree.constrained.time, boot=1000)
plot(tmp$residuals ~ log.size, data = Z.names[,c(-4)])
plot(tmp)
qqnorm(model,abline = c(0,1))
predictmeans::residplot(model)
tmp$bootconfint95

require(diverge)
require(boot)
sisters<-analyze_sister_pairs(tree = prunetree.constrained.time, data = Z.names, trait1 = 'log.r2t', trait2='log.size', useAbsolute = F)
#run the sister pair analysis on constrained and unconstrained datasets

#testing
{#testing added variable plots
  
  xtmp<-x
  {# Generating data
    #set.seed(2021)
    #n <- 1000
    x <- setNames(Z$`log(size)`, rownames(Z))
    y <- setNames(Z$r2t, rownames(Z))
    
    
    #Models of population and sample
    population.data <- as.data.frame(cbind(x, y))
    population.model <- phylolm(y ~ x, population.data, phy = prunetree.shallow.time, model = 'BM')
    summary(population.model)
    
    
    #Sampling the data
    sample.data <- population.data
    #population.data[sample(nrow(population.data), 20, replace = TRUE), ]
    sample.model <- phylolm(y ~ x, data = sample.data, phy = prunetree.shallow.time, model = 'BM')
    summary(sample.model)
    
    
    #Plotting the models
    plot(y ~ x, col = "gray", main = 'Population and Sample Regressions')
    abline(coef(population.model)[1], coef(population.model)[2], col = "red")
    abline(coef(sample.model)[1],
           coef(sample.model)[2],
           col = "blue",
           lty = 2)
    legend(
      "topleft",
      legend = c("Sample", "Population"),
      col = c("red", "blue"),
      lty = 1:2,
      cex = 0.8)
    
    
    #The bootstrap regression
    sample_coef_intercept <- NULL
    sample_coef_x1 <- NULL
    
    # for (i in 1:1000) {
    #   sample_d = sample.data[sample(1:nrow(sample.data), nrow(sample.data), replace = TRUE), ]
    #   
    #   model_bootstrap <- phylolm(y ~ x, data = sample_d, phy=prunetree.shallow.time)
    #   
    #   sample_coef_intercept <-
    #     c(sample_coef_intercept, model_bootstrap$coefficients[1])
    #   
    #   sample_coef_x1 <-
    #     c(sample_coef_x1, model_bootstrap$coefficients[2])
    # }
    # 
    # coefs <- rbind(sample_coef_intercept, sample_coef_x1)
    # 
    # 
    
    sample_coef_intercept<-setNames(model$bootstrap[,1], rep("(Intercept)", model$boot))
    sample_coef_x1 <- setNames(model$bootstrap[,2], rep("x", model$boot))
    
    coefs <- rbind(sample_coef_intercept, sample_coef_x1)
    
    
    # Combining the results in a table
    means.boot = c(mean(sample_coef_intercept), mean(sample_coef_x1))
    knitr::kable(round(
      cbind(
        population = coef(summary(population.model))[, 1],
        sample = coef(summary(sample.model))[, 1],
        bootstrap = means.boot),4), 
      "simple", caption = "Coefficients in different models")
    
    confint(population.model)
    confint(sample.model)
    a <-
      cbind(
        quantile(sample_coef_intercept, prob = 0.025),
        quantile(sample_coef_intercept, prob = 0.975))
    b <-
      cbind(quantile(sample_coef_x1, prob = 0.025),
            quantile(sample_coef_x1, prob = 0.975))
    
    c <-
      round(cbind(
        population = confint(population.model),
        sample = confint(sample.model),
        boot = rbind(a, b)), 4)
    colnames(c) <- c("2.5 %", "97.5 %",
                     "2.5 %", "97.5 %",
                     "2.5 %", "97.5 %")
    knitr::kable(rbind(
      c('population',
        'population',
        'sample',
        'sample',
        'bootstrap',
        'bootstrap'),c))
    
    
    #Predicting on new data
    new.data = seq(min(x), max(x), by = 0.05)
    conf_interval <-
      predict(
        sample.model,
        newdata = data.frame(x = new.data),
        interval = "confidence",
        level = 0.95)
    
    
    #Plotting the results on the project step-by-spet
    plot(
      y ~ x,
      col = "gray",
      xlab = "x",
      ylab = "y",
      main = "Compare regressions")
    apply(coefs, 2, abline, col = rgb(1, 0, 0, 0.1))
    abline(coef(population.model)[1], coef(population.model)[2], col = "blue")
    abline(coef(sample.model)[1],
           coef(sample.model)[2],
           col = "black",
           lty = 2, lwd=3)
    abline(mean(sample_coef_intercept),
           mean(sample_coef_x1),
           col = "green",
           lty = 4, lwd=3)
    lines(new.data, conf_interval[, 2], col = "black", lty = 3, lwd=3)
    lines(new.data, conf_interval[, 3], col = "black", lty = 3, lwd=3)
    legend("topleft",
           legend = c("Bootstrap", "Population", 'Sample'),
           col = c("red", "blue", 'green'),
           lty = 1:3,
           cex = 0.8)
    
  }
  
  {
    require(phylolm)
    model<-phylolm(formula = log.r2t~log.size + nodes, data = Z, phy = prunetree.shallow.time, boot=100, model = 'BM')
    
    added_variable_plot(model)
    
    model1<-phylolm(formula = log.r2t~log.size, data = Z, phy = prunetree.shallow.time, boot=100, model = 'BM')
    model2<-phylolm(formula = log(nodes) ~ log.r2t+log.size, data = Z, phy = prunetree.shallow.time, boot=100, model = 'BM')
    
    model3<-phylolm(formula = log.r2t~log(nodes), data = Z, phy = prunetree.shallow.time, boot=100, model = 'BM')
    model4<-phylolm(formula = log.size ~ log.r2t+log(nodes), data = Z, phy = prunetree.shallow.time, boot=100, model = 'BM')
    
    plot(model1$residuals ~ model2$residuals)
    plot(model3$residuals ~ model4$residuals)
    
    
    model<-gls(log.r2t ~ log.size + (nodes), correlation = corBrownian(phy = prunetree.shallow.time, form = ~species), data = Z.names, method = "ML")
    #car::avPlots(model)
    model<-nlme::gls(mpg ~ disp + hp + wt, data = mtcars)
    
    added_variable_plot(model=model)
    
    
    ###
    test1<-lm(mpg ~ disp + hp + wt, data = mtcars)
    test1<-lm(mpg ~ disp + hp + wt, data = mtcars)
    test1<-lm(mpg ~ disp + hp + wt, data = mtcars)
    olsrr::ols_plot_added_variable(test1)
    ols_plot_added_variable(model)
    
    
    #Regress Y on all variables other than X and store the residuals (Y residuals).
    #Regress X on all the other variables included in the model (X residuals).
    #Construct a scatter plot of Y residuals and X residuals.
    
  }
  
}


# #plotting phylomorphospace - unconstrained
# {
#   Z<-as.data.frame(as.matrix(phylopars(cbind(pglsdata[1],log(pglsdata[4])),prunetree.shallow.time)$anc_recon[1:99,]))
#   #Z$r2t<-pglsdata[2]
#   Z<-merge(Z, as.data.frame(log(pglsdata[6])), by='row.names', all=TRUE)
#   colnames(Z)<- c('species', 'log(size)', 'r2t')
#   rownames(Z)<- Z$species
#   Z$species<-NULL
#   
#   pdf(file="bivalve.phylomorphospace_unconstrained_bls.pdf", width=6, height=7)
#   phylomorphospace(prunetree.shallow.time, X=Z, label='off', ylim=c(-0.7,0.5), xlim=c(1.5,6),node.size=c(0.0001,1), lwd=0.15, bty='n', ylab="log(r2t)")#, control=c(col.edge='white'))
#   
#   title(main='bivalve phylomorphospace')
#   #par(new=T)
#   #plot(r2t.log~log(size), col = pglsdata$cols, data = pglsdata, pch=16, ylim=c(-0.55,0.15), xlim=c(1.5,6), bty='n', xaxt='n', yaxt='n', ylab="", xlab="")
#   points(r2t~`log(size)`, bg = pglsdata$cols, data = Z, pch=21, lwd=0.5)
#   
#   points(r2t~`log(size)`, col = "white", data = Z[which(is.na(pglsdata[4]$size)),], pch=19, lwd=0.5, cex=0.5)
#   
#   abline(lm(log(r2t.unconstrained)~log(size), data =pglsdata), lwd=2, lty=1, col=make.transparent("red", 0.5))
#   abline(phylopars.lm(log(r2t.unconstrained) ~ log(size), tree=prunetree.shallow.time, trait_data=pglsdata, model='BM'), col=make.transparent('red',0.5), lwd=4, lty=1)
#   
#   #summary(phylopars.lm(r2t.log ~ log(size), tree=prunetree.shallow.time, trait_data=pglsdata, model='BM'))
#   
#   #summary(lm(log(r2t)~log(size), data =pglsdata))
#   legend('topright', title='habitat type', c('Organic fall','Seep', 'Vent'), col=c('blue', 'lightblue', 'grey'), pch=16, bty='n')
#   
#   #legend('top', text.col='red', legend=c('PGLS p~0.97'), cex=0.85, box.lwd=0.5) 
#   #legend('topleft', text.col='black', legend=c('LM R^2=0.328, p<<0.05'), cex=0.85, box.lwd=0.5)
#   dev.off()
# }
# 

#plotting phylomorphospace - unconstrained
{
  tmp_nodecounts<-unlist(lapply(setNames(nodepath(prunetree.shallow.time), prunetree.shallow.time$tip.label), length))[prunetree.shallow.time$tip.label]
  Z<-cbind(as.matrix(phylopars(cbind(pglsdata[1],log(pglsdata[4])),prunetree.shallow.time)$anc_recon[1:99,]), tmp_nodecounts[prunetree.shallow.time$tip.label]) #,tiprates[prunetree.shallow.time$tip.label]
  #Z$r2t<-pglsdata[2]
  Z<-merge(Z, as.data.frame(pglsdata[8]), by='row.names', all=TRUE)
  colnames(Z)<- c('species', 'log.size','nodes','log.r2t.unconstrained')
  rownames(Z)<- Z$species
  Z$species<-NULL
  Z<- Z[rownames(pglsdata),]
  Z.names<-Z
  Z.names$species <- rownames(Z.names)
  
  pdf(file="bivalve.phylomorphospace_unconstrained_bls.pdf", width=6, height=7)
  phylomorphospace(prunetree.shallow.time, X=Z[,c(-2)], label='off', ylim=c(-0.7,0.4), xlim=c(1.5,6),node.size=c(0.0000,0), lwd=0.35, bty='n', ylab="log(r2t)",xlab="log(size)", fsize=0.5)#, control=c(col.edge='white'))
  
  title(main='bivalve phylomorphospace')
  #par(new=T)
  #plot(r2t.log~log(size), col = pglsdata$cols, data = pglsdata, pch=16, ylim=c(-0.55,0.15), xlim=c(1.5,6), bty='n', xaxt='n', yaxt='n', ylab="", xlab="")
  points(log.r2t.unconstrained~log.size, bg = scales::alpha(pglsdata$cols, 0.95), data = Z, pch=pglsdata$pch, lwd=1, cex=1.25)  ## fix here
  
  #points(r2t~`log(size)`, col = "black", data = Z[which(is.na(pglsdata[4]$size)),], pch=19, lwd=0.5, cex=0.5)
  #points(r2t~`log(size)`, col = "black", data = Z, pch=19, lwd=0.5, cex=0.15)
  
  
  #add the bootstrap lines
  # for(i in c(1:2)) {
  #   cc <- (model$bootconfint95[i,])
  #   abline(a=cc[1], b=cc[2], lwd=1, col="red")
  #   #curve(plogis(cc[1]+cc[2]*x),col=make.transparent(palette.colors(palette = "Okabe-Ito")[2], 0.25),add=TRUE, lwd=0.25, col='red')
  # }
  
  model<-gls(log.r2t.unconstrained ~ log.size, correlation = corBrownian(phy = prunetree.shallow.time, form = ~species), data = Z.names, method = "ML")
  model.int<-gls(log.r2t.unconstrained ~ 1, correlation = corBrownian(phy = prunetree.shallow.time, form = ~species), data = Z.names, method = "ML")
  
  abline(model, col=make.transparent('black',1), lwd=4, lty=2)
  pGLS_ci<-gls.ci(Z$log.r2t,Z$log.size,vcv(prunetree.shallow.time))
  lines(pGLS_ci$CI.plot$X,pGLS_ci$CI.plot$Lower2.5,lty=2)
  lines(pGLS_ci$CI.plot$X,pGLS_ci$CI.plot$Upper2.5,lty=2)
  
  
  #pGLS_pi<-gls.pi(Z$log.r2t,Z$log.size,vcv(prunetree.shallow.time),1000)
  #lines(pGLS_pi$PI.plot$X,pGLS_pi$PI.plot$Lower2.5,lty=3)
  #lines(pGLS_pi$PI.plot$X,pGLS_pi$PI.plot$Upper2.5,lty=3)
  
  #abline(lm(r2t.log~log(size_recon), data = pglsdata), lwd=2, lty=1, col=make.transparent("red", 0.5))
  #model<-phylopars.lm(r2t.log ~ log(size), tree=prunetree.shallow.time, trait_data=pglsdata, model='BM')
  #abline(model, col=make.transparent('black',1), lwd=4, lty=2)
  
  #summary(phylopars.lm(r2t.log ~ log(size), tree=prunetree.shallow.time, trait_data=pglsdata, model='BM'))
  
  #summary(lm(log(r2t)~log(size), data =pglsdata))
  legend('topright', title='habitat type', c('Organic fall','Seep', 'Vent')[c(1,3,2)], col=cols[c(1,3,2)], pch=16, bty='n', cex=1)
  
  #legend('top', text.col='red', legend=c('PGLS p~0.97'), cex=0.85, box.lwd=0.5) 
  #legend('topleft', text.col='black', legend=c('LM R^2=0.328, p<<0.05'), cex=0.85, box.lwd=0.5)
  dev.off()
  
}



# 
# 
# ####testing spreading rate
# tmp<-merge(data,pglsdata,by="row.names",all.x=TRUE)
# tmp2<-tmp[tmp$habitat=='Vent',]
# 
# vent.tree<-drop.tip(prunetree.shallow.time, tmp$species[!tmp$species%in% tmp2$species])
# 
# fit<-phylopars.lm(r2t ~ rate_avg, tree=force.ultrametric(vent.tree), trait_data=tmp2, model='BM')
# 
# summary(fit)
# 
# fit<-phylopars.lm(r2t ~ rate_cat, tree=force.ultrametric(vent.tree), trait_data=tmp2, model='BM')
# summary(fit)
# 
# 
# 
# plot(r2t ~ rate_avg, data=tmp)
# abline(lm(r2t ~ rate_avg, data=tmp))
# 
# tmp$rate_cat
# 
# 
# #uses the 'time calibrated tree' 
# phyl.aov <- phylANOVA(prunetree.shallow.time, x = tmp$rate_cat, y = y , nsim=10000, posthoc=T, p.adj='none')
# phyl.aov


#plotting phylogram with dots



#####

# #plotting phylogram
# plot(prunetree.shallow, cex=0.4, no.margin=F)
# tiplabels(pch=20, col=tipcols, cex=0.8)
# 
# 
# #plotting gene tree vs species tree
# cophylotest<-cophylo(prunetree.shallow.time, prunetree.shallow, assoc=NULL, rotate=TRUE)
# 
# plot.cophylo(cophylotest,link.type="curved",link.lwd=3,link.lty="solid",link.col=make.transparent("blue",0.25),fsize=0.0001, pts=F, no.margin=T)
# 
# tiplabels.cophylo(pch=20, col=tipcols, cex=0.8, which=c("left"))
# #tiplabels.cophylo(pch=20, col=tipcols, cex=0.8, which=c("right"))
# 
# 
# 
# 
# tmp<-phylopars.lm(r2t ~ log(size), tree=prunetree.shallow.time, trait_data=pglsdata, model='BM')
# tmp<-phylopars.lm(r2t ~ habitat, tree=prunetree.shallow.time, trait_data=pglsdata, model='BM')
# summary(tmp)
# 





###### old crap below this

#CO1_ML_TRIMMED<-read.tree('~/jsb439@cornell.edu/amelia-bivalves/2_12_19/IQTREE/Trimmed/190213050646/MAAFT_output_trimmed.fas.treefile')

#CO1_ML_UNTRIMMED <- read.tree('~/jsb439@cornell.edu/amelia-bivalves/2_12_19/IQTREE/Untrimmed/190213025611/MAAFT_output.fasta.treefile')


#root.trimmed<-findMRCA(CO1_ML_TRIMMED, tips=Solemyidae$`Tip Names`)
#root.untrimmed<-findMRCA(CO1_ML_UNTRIMMED, tips=Solemyidae$`Tip Names`)


#reroot on root
#tree.trimmed <- reroot(CO1_ML_TRIMMED, node.number= root.trimmed )
#tree.untrimmed <- reroot(CO1_ML_UNTRIMMED, node.number= root.untrimmed )


#prune outgroups
#cut the outgroup tips
#prunetree.trimmed <- drop.tip(tree.trimmed, tip=Solemyidae$`Tip Names`)
#prunetree.untrimmed <- drop.tip(tree.untrimmed, tip=Solemyidae$`Tip Names`)


#root to tip length from the pruned tree as r2t
#r2t.prunetree.trimmed<-as.data.frame(diag(vcv.phylo(prunetree.trimmed)))
#r2t.prunetree.untrimmed<-as.data.frame(diag(vcv.phylo(prunetree.untrimmed)))

#plot(r2t.prunetree.trimmed ~ r2t.prunetree.untrimmed)

# 
# require(phytools)
# 
# output<-read.tree('~/jsb439@cornell.edu/amelia-bivalves/2_24_19/IQTREE_bigmac/MAAFT_output.fasta.treefile')
# output$edge.length<-NULL
# 
# output.contree<-read.tree('~/jsb439@cornell.edu/amelia-bivalves/2_24_19/IQTREE_bigmac/MAAFT_output.fasta.contree')
# output.contree$edge.length<-NULL
# 
# unconstrained.untrimmed<-read.tree('~/jsb439@cornell.edu/amelia-bivalves/2_12_19/IQTREE/Untrimmed/190213025611/MAAFT_output.fasta.treefile')
# unconstrained.untrimmed$edge.length<-NULL
# 
# constraint<-read.tree('~/jsb439@cornell.edu/amelia-bivalves/constraint.tree')
# 
# cophylotest<-cophylo(output, output.contree, assoc=NULL, rotate=TRUE)
# 
# plot.cophylo(cophylotest,link.type="curved",link.lwd=3,link.lty="solid",link.col=make.transparent("blue",0.25),fsize=0.0001, pts=F)
# 
# ?plot.cophylo
# 



###



# prunetree.shallow.time<-chronos(prunetree.shallow)
# prunetree.shallow.time<-ladderize(prunetree.shallow.time, right=F)

#plot(prunetree.shallow.time, cex=0.1)
#SKIP TO A IF USING SAVED TREE
#fix(makeChronosCalib) #edit plotting for node associations
#cal<-makeChronosCalib(prunetree.shallow.time, interactive=T)

#  node age.min age.max soft.bounds
#1   98      78      80       FALSE
#2  157      19      21       FALSE
#3  137       9      10       FALSE
#4  133      29      30       FALSE
#5  144      14      15       FALSE
#6  115      12      13       FALSE
#7  108       8      10       FALSE
#8  177      25      26       FALSE
#9  181      28      29       FALSE


####


# cophylotest<-cophylo(prunetree.shallow.time, prunetree.shallow, assoc=NULL, rotate=TRUE)
# 
# plot.cophylo(cophylotest,link.type="curved",link.lwd=3,link.lty="solid",link.col=make.transparent("blue",0.25),fsize=0.0001, pts=F, no.margin=T)
# 
# prunetree.shallow.time
# ?drop.tip
# install.packages('sensiPhy')
# require(sensiPhy)
# t<-match_dataphy(r2t~habitat, data=pglsdata, phy= prunetree.shallow.time)
# prunetree.shallow.time<-t$phy
# 
# 



#
#retrying phylogenetic anova in a different way

require(geiger)
anov.y<-(setNames((log(pglsdata$r2t)),rownames(pglsdata)))
anov.x<-factor(setNames(pglsdata$habitat,rownames(pglsdata)), ordered=F)
# {
# anov.x<-as.character(pglsdata$habitat)
# anov.x[anov.x=="OF"]<-"bOF"
# anov.x[anov.x=="Vent"]<-"cVent"
# anov.x[anov.x=="Seep"]<-"aSeep"
# anov.x<-setNames(as.factor(anov.x), rownames(pglsdata))
# }
anov.z<-log(size_recon) #setNames(pglsdata$size,rownames(pglsdata))
nodes<-unlist(lapply(setNames(nodepath(prunetree.shallow.time), prunetree.shallow.time$tip.label), length))

#phyl.aov.geiger.test<-aov.phylo(anov.y ~ anov.x, prunetree.shallow.time, nsim=1000)
#attr(phyl.aov.geiger.test, "summary")


# DR<-DR_statistic(prunetree.shallow)
# DR<-DR[names(anov.y)]
# 
#tmp<-bestNormalize(pglsdata$r2t, loo=F, allow_orderNorm = FALSE)
#hist(tmp$x.t)

brmsdata<-data.frame(rate=anov.y, habitat=anov.x, size=anov.z, species=names(anov.y), nodecounts=log(nodes))
#brmsdata<-data.frame(rate=tmp$x.t, habitat=anov.x, size=anov.z, species=names(anov.y), nodecounts=log(nodes))


#brmsdata$habitat<-factor(anov.x, levels = c("Seep", "Vent", "OF"))
#brmsdata<-data.frame(rate=scale(anov.y, scale=F), habitat=anov.x, size=scale(anov.z, scale=F), species=names(anov.y), nodecounts=scale(log(nodes), scale=F))


require(phylolm)
#set up for rr2 and phylolm
{
  require(rr2)
#trying with phylolm
forms<-c("habitat",
"habitat + nodecounts",
"habitat + size + nodecounts",
"habitat + size + nodecounts + habitat:size")

starphylo <- ape::compute.brlen(prunetree.constrained.time, method = "Grafen", power = .0001)
#ancova.bm1<-phylolm::phylolm(rate~ 0, data=brmsdata, phy=prunetree.shallow.time, model="BM", boot=100)
#fitContinuous(phy=prunetree.shallow.time, dat=setNames(brmsdata$rate, rownames(brmsdata)), model="BM")
#phylosig(prunetree.shallow.time, x=setNames(brmsdata$rate, rownames(brmsdata)), test=T, method="lambda")
#summary(lm(brmsdata$rate ~ brmsdata$nodecounts))


#test1<-untangle(rotate(prunetree.shallow.time, node=50), "read.tree")
# ancova.bm1<-phylolm::phylolm(size~ habitat, data=brmsdata, phy=test, model="BM", boot=100)
# summary(ancova.bm1)
# ancova.bm1<-phylolm::phylolm(rateDR ~ habitat+ size + nodecounts + habitat:size, data=brmsdata, phy=prunetree.shallow.time, model="BM", boot=100)
# summary(ancova.bm1)
# plot(rateDR ~ habitat, data=brmsdata)
#options(contrasts = c("contr.sum","contr.poly"))
options(contrasts = c("contr.treatment","contr.poly"))

ancova.bm1<-phylolm::phylolm((rate) ~ habitat, data=brmsdata, phy=prunetree.constrained.time, model="BM", boot=100)
ancova.bm1.r<-lm(rate~ habitat, data=brmsdata)
ancova.bm1.star<-phylolm::phylolm(rate~ habitat, data=brmsdata, phy=starphylo, model="BM", boot=100)

R2_lik(ancova.bm1, ancova.bm1.star)

ancova.bm2<-phylolm::phylolm(rate ~ habitat + nodecounts, data=brmsdata, phy=prunetree.constrained.time, model="BM", boot=100)
ancova.bm2.r<-lm(rate ~ habitat + nodecounts, data=brmsdata)
ancova.bm2.star<-phylolm::phylolm(rate ~ habitat + nodecounts, data=brmsdata, phy=starphylo, model="BM", boot=100)

R2_lik(ancova.bm2, ancova.bm1) #partial R2 for nodecounts

ancova.bm3<-phylolm::phylolm(rate ~ habitat + size + nodecounts, data=brmsdata, phy=prunetree.constrained.time, model="BM", boot=100)
ancova.bm3.r<-lm(rate ~ habitat + size + nodecounts, data=brmsdata)
ancova.bm3.star<-phylolm::phylolm(rate ~ habitat + size + nodecounts, data=brmsdata, phy=starphylo, model="BM", boot=100)

R2_lik(ancova.bm3, ancova.bm2) #partial R2 of size

ancova.bm4<-phylolm::phylolm(rate ~ habitat + size + nodecounts + habitat:size, data=brmsdata, phy=prunetree.constrained.time, model="BM", boot=100)
ancova.bm4.r<-lm(rate ~ habitat + size + nodecounts + habitat:size, data=brmsdata)
ancova.bm4.star<-phylolm::phylolm(rate ~ habitat + size + nodecounts + habitat:size, data=brmsdata, phy=starphylo, model="BM", boot=100)

R2_lik(ancova.bm4, ancova.bm3) #partial R2 of interaction

#ancova.bm6<-phylolm::phylolm(rate~0 + habitat:size + size, data=brmsdata, phy=prunetree.shallow.time, model="BM", boot=100)
bm.aic<-c(AICc.phylolm(ancova.bm1), AICc.phylolm(ancova.bm2), AICc.phylolm(ancova.bm3), AICc.phylolm(ancova.bm4))
aic.w(bm.aic)

#tmp<-teststep(formula = rate ~ habitat * size * nodecounts, data = brmsdata, phy=prunetree.shallow.time, model = "OUrandomRoot", direction="both")
#tmp<-MASS:::stepAIC(object = lm(rate ~ habitat + size + nodecounts, data = brmsdata), direction="both")


##now with OU models

ancova.ou1<-phylolm::phylolm(rate~ habitat, data=brmsdata, phy=prunetree.constrained.time, model="OUrandomRoot", boot=100)
ancova.ou1.r<-lm(rate~ habitat, data=brmsdata)
ancova.ou1.star<-phylolm::phylolm(rate~ habitat, data=brmsdata, phy=starphylo, model="OUrandomRoot", boot=100)

R2_lik(ancova.ou1, ancova.ou1.star)

ancova.ou2<-phylolm::phylolm(rate ~ habitat + nodecounts, data=brmsdata, phy=prunetree.constrained.time, model="OUrandomRoot", boot=100)
ancova.ou2.r<-lm(rate ~ habitat + nodecounts, data=brmsdata)
ancova.ou2.star<-phylolm::phylolm(rate ~ habitat + nodecounts, data=brmsdata, phy=starphylo, model="OUrandomRoot", boot=100)

R2_lik(ancova.ou2, ancova.ou1) #partial R2 for nodecounts

ancova.ou3<-phylolm::phylolm(rate ~ habitat + size + nodecounts, data=brmsdata, phy=prunetree.constrained.time, model="OUrandomRoot", boot=100)
ancova.ou3.r<-lm(rate ~ habitat + size + nodecounts, data=brmsdata)
ancova.ou3.star<-phylolm::phylolm(rate ~ habitat + size + nodecounts, data=brmsdata, phy=starphylo, model="OUrandomRoot", boot=100)

R2_lik(ancova.ou3, ancova.ou2) #partial R2 of size

ancova.ou4<-phylolm::phylolm(rate ~ habitat + size + nodecounts + habitat:size, data=brmsdata, phy=prunetree.constrained.time, model="OUrandomRoot", boot=100)
ancova.ou4.r<-lm(rate ~ habitat + size + nodecounts + habitat:size, data=brmsdata)
ancova.ou4.star<-phylolm::phylolm(rate ~ habitat + size + nodecounts + habitat:size, data=brmsdata, phy=starphylo, model="OUrandomRoot", boot=100)

R2_lik(ancova.ou4, ancova.ou3) #partial R2 of interaction


#with both BM and lambda, model with habitat is best
ou.aic<-c(AICc.phylolm(ancova.ou1), AICc.phylolm(ancova.ou2), AICc.phylolm(ancova.ou3), AICc.phylolm(ancova.ou4))
aic.w(ou.aic)

all<-c(bm.aic, ou.aic)
aic.w(all)

#extract sig2 values
bm.sig2s<-list()
for(i in 1:4){
  bm.sig2s[i]<-eval(parse(text=paste("ancova.bm", i, sep="")))$sigma2
}

ou.sig2s<-list()
for(i in 1:4){
  ou.sig2s[i]<-eval(parse(text=paste("ancova.ou", i, sep="")))$sigma2
}

ou.alpha<-list()
for(i in 1:4){
  ou.alpha[i]<-eval(parse(text=paste("ancova.ou", i, sep="")))$optpar
}

require(rr2)
bm.r2s<-rbind(R2(mod = ancova.bm1, mod.r=ancova.bm1.r, phy=prunetree.constrained.time),
              R2(mod = ancova.bm2, mod.r=ancova.bm2.r, phy=prunetree.constrained.time),
              R2(mod = ancova.bm3, mod.r=ancova.bm3.r, phy=prunetree.constrained.time),
              R2(mod = ancova.bm4, mod.r=ancova.bm4.r, phy=prunetree.constrained.time))
              # R2(mod = ancova.bm5, mod.r=ancova.bm5.r, phy=prunetree.shallow.time),
              # R2(mod = ancova.bm6, mod.r=ancova.bm6.r, phy=prunetree.shallow.time),
              # R2(mod = ancova.bm7, mod.r=ancova.bm7.r, phy=prunetree.shallow.time),
              # R2(mod = ancova.bm8, mod.r=ancova.bm8.r, phy=prunetree.shallow.time),
              # R2(mod = ancova.bm9, mod.r=ancova.bm9.r, phy=prunetree.shallow.time),
              # R2(mod = ancova.bm10, mod.r=ancova.bm10.r, phy=prunetree.shallow.time))


ou.r2s<-rbind(R2(mod = ancova.ou1, mod.r=ancova.ou1.r, phy=prunetree.constrained.time),
              R2(mod = ancova.ou2, mod.r=ancova.ou2.r, phy=prunetree.constrained.time),
              R2(mod = ancova.ou3, mod.r=ancova.ou3.r, phy=prunetree.constrained.time),
              R2(mod = ancova.ou4, mod.r=ancova.ou4.r, phy=prunetree.constrained.time))
              # R2(mod = ancova.ou5, mod.r=ancova.ou5.r, phy=prunetree.shallow.time),
              # R2(mod = ancova.ou6, mod.r=ancova.ou6.r, phy=prunetree.shallow.time),
              # R2(mod = ancova.ou7, mod.r=ancova.ou7.r, phy=prunetree.shallow.time),
              # R2(mod = ancova.ou8, mod.r=ancova.ou8.r, phy=prunetree.shallow.time),
              # R2(mod = ancova.ou9, mod.r=ancova.ou9.r, phy=prunetree.shallow.time),
              # R2(mod = ancova.ou10, mod.r=ancova.ou10.r, phy=prunetree.shallow.time))


#summarize coefficients
#https://stackoverflow.com/questions/29685806/printing-regression-coefficients-from-multiple-models-to-a-shared-data-frame
# models<-list(ancova.bm1,
#           ancova.bm2,
#           ancova.bm3,
#           ancova.bm4,
#           ancova.bm5,
#           ancova.bm6,
#           ancova.bm7,
#           ancova.bm8,
#           ancova.bm9,
#           ancova.bm10,
#           ancova.ou1, 
#           ancova.ou2, 
#           ancova.ou3, 
#           ancova.ou4, 
#           ancova.ou5, 
#           ancova.ou6, 
#           ancova.ou7, 
#           ancova.ou8, 
#           ancova.ou9, 
#           ancova.ou10)

models<-list(ancova.bm1,
             ancova.bm2,
             ancova.bm3,
             ancova.bm4,
             ancova.ou1, 
             ancova.ou2, 
             ancova.ou3, 
             ancova.ou4)

names(models)<-paste0("MODEL", 1:8)

Pvals<-list()
for(i in 1:8){
  Pvals[[i]]<-summary(models[[i]])$coefficients[,6]
}


for(i in 1:length(Pvals)){
  for(j in 1:length(Pvals[[i]])){
    swap<-if(Pvals[[i]][[j]] < 0.05){paste("*")}else{paste("")}
    Pvals[[i]][[j]]<-swap
  }
}

coefs<-lapply(models, coefficients)
coefs<-lapply(coefs, round, 4)

for(i in 1:length(coefs)){
  for(j in 1:length(coefs[[i]])){
    coefs[[i]][[j]] <- paste(coefs[[i]][[j]], Pvals[[i]][[j]], sep="")
  }
}


coefs<-lapply(coefs, unlist)
coefs<-lapply(coefs, as.list)
coefs<-data.table::rbindlist(coefs, fill=T, use.names=T)


summary<-data.frame(process=c(rep("BM", 4),rep("OU", 4)), 
                    #vars=c(forms,forms), 
                    AICc=round(c(bm.aic, ou.aic), 2), 
                    weight=as.numeric(round(aic.w(all),2)), 
                    alpha=round(c(rep(NA, 4), unlist(ou.alpha)),4), 
                    sig2=round(unlist(c(bm.sig2s, ou.sig2s)), 4), 
                    R2pred=rbind(bm.r2s, ou.r2s)[,3], 
                    coefs)


summary<-summary[order(summary$weight, decreasing =T),]
rownames(summary)<-NULL


require(stargazer)
stargazer(summary, summary=F, type="latex")

}

#trying residuals
res<-ancova.bm1$residuals
res<-res/sqrt(var(res))
names(res)[abs(res)>2]

# options(contrasts = c("contr.treatment","contr.poly"))
# ancova.bm1<-phylolm::phylolm((size) ~ habitat, data=brmsdata, phy=prunetree.constrained.time, model="BM", boot=100)
# phylANOVA(tree= prunetree.constrained.time, y = setNames(brmsdata$size, rownames(brmsdata)), x=setNames(brmsdata$habitat, rownames(brmsdata)), nsim=1000)
# boxplot(brmsdata$size ~ brmsdata$habitat)


# phyl.aov.posthoc <- phylANOVA(prunetree.shallow.time, x = setNames(brmsdata$habitat, brmsdata$species), 
#                               y = setNames(brmsdata$rate, brmsdata$species), nsim=10000, posthoc=T, p.adj='none')
# 


#plot(rate ~ habitat, data=brmsdata)
require(ggthemes)
require(ggplot2)
require(ggpubr)

pglsdata$habitat<-ordered(pglsdata$habitat, levels=c('OF', 'Vent', 'Seep'))

#constrained
phyl.aov.constrained
# {
# pp <- ggplot(pglsdata, aes(habitat, r2t.log)) + geom_boxplot() #+
#   #scale_fill_manual(breaks = habitat,
#     #                values = c("green", "black", "black"))
# 
# df1 <- data.frame(a = c(1, 1:3,3), b = c(0.69, 0.71, 0.71, 0.71, 0.69)-0.4)
# df2 <- data.frame(a = c(1, 1,2, 2), b = c(0.25, 0.27, 0.27, 0.25)-0.075)
# df3 <- data.frame(a = c(2, 2, 3, 3), b = c(0.25, 0.27, 0.27, 0.25)-0.2)
# 
# pdf(file="bivalve_boxplots_constrained.pdf", width=5, height=5)
# pp + geom_line(data = df1, aes(x = a, y = b)) +
#   annotate("text", x = 2, y = 0.33, label = "0.01", size = 4) +
#   geom_line(data = df2, aes(x = a, y = b)) +
#     annotate("text", x = 1.5, y = 0.22, label = "0.03", size = 4) +
#   geom_line(data = df3, aes(x = a, y = b)) +
#     annotate("text", x = 2.5, y = 0.1, label = "0.45", size = 4) +
#   theme_clean()
# 
# dev.off()
# }

{
  pp <-
    ggplot(pglsdata, aes(habitat, r2t.log)) + geom_boxplot(
      aes(fill=habitat),
      outlier.shape = NA,
      width = 0.35,
      position = position_nudge(x = 0.175),
      show.legend = FALSE
    )
  df1 <- data.frame(a = c(1, 1:3,3), b = c(0.69, 0.71, 0.71, 0.71, 0.69)-0.4)
  df2 <- data.frame(a = c(1, 1,2, 2), b = c(0.25, 0.27, 0.27, 0.25)-0.075)
  df3 <- data.frame(a = c(2, 2, 3, 3), b = c(0.25, 0.27, 0.27, 0.25)-0.2)
  
  pdf(file="bivalve_boxplots_constrained.pdf", width=5, height=5)
  pp + 
    geom_line(data = df1, aes(x = a, y = b)) +
    annotate("text", x = 2, y = 0.33, label = "0.01", size = 4) +
    geom_line(data = df2, aes(x = a, y = b)) +
    annotate("text", x = 1.5, y = 0.22, label = "0.03", size = 4) +
    geom_line(data = df3, aes(x = a, y = b)) +
    annotate("text", x = 2.5, y = 0.1, label = "0.45", size = 4) +
    
    #theme_clean() + geom_jitter(data=data.frame(size=log(pglsdata[,c(5)]),habitat=pglsdata[,c(3)]), width=0.1)
    theme_classic() + geom_point(color='black', fill='black',
                                 shape = 21,
                                 size = 1.5,
                                 #aes(fill = as.character(pglsdata$pch)),
                                 data = data.frame(r2t.log = pglsdata$r2t.log, habitat = pglsdata$habitat),
                                 show.legend = FALSE,
                                 position = sdamr::position_jitternudge(jitter.width = 0.2, nudge.x = -0.175)
    ) +
    scale_fill_manual(values = c(
      #"21" = scales::alpha("black", 0.9),
      #"23" = scales::alpha("white", 0.9),
      "OF" = "#007AC1",
      'Vent' = "#00BCDF",
      "Seep" = "#CAE3FC"
    ))
  
  dev.off()
}



#unconstrained
phyl.aov.unconstrained
# {
#   pp <- ggplot(pglsdata, aes(habitat, log(r2t.unconstrained))) + geom_boxplot() #+
#   #scale_fill_manual(breaks = habitat,
#   #                values = c("green", "black", "black"))
# 
#   #df1 <- data.frame(a = c(1, 1:3,3), b = c(0.69, 0.71, 0.71, 0.71, 0.69)-0.4)
#   #df2 <- data.frame(a = c(1, 1,2, 2), b = c(0.25, 0.27, 0.27, 0.25)-0.075)
#   #df3 <- data.frame(a = c(2, 2, 3, 3), b = c(0.25, 0.27, 0.27, 0.25)-0.2)
# 
#   pdf(file="bivalve_boxplots_unconstrained.pdf", width=5, height=5)
#   pp + #geom_line(data = df1, aes(x = a, y = b)) +
#     #annotate("text", x = 2, y = 0.33, label = "0.01", size = 4) +
#     #geom_line(data = df2, aes(x = a, y = b)) +
#     #annotate("text", x = 1.5, y = 0.22, label = "0.03", size = 4) +
#     #geom_line(data = df3, aes(x = a, y = b)) +
#     #annotate("text", x = 2.5, y = 0.1, label = "0.45", size = 4) +
#     theme_clean()
# 
#   dev.off()
# }

{
  pp <-
    ggplot(pglsdata, aes(habitat, r2t.log.unconstrained)) + geom_boxplot(
      aes(fill=habitat),
      outlier.shape = NA,
      width = 0.35,
      position = position_nudge(x = 0.175),
      show.legend = FALSE
    )
  df1 <- data.frame(a = c(1, 1:3,3), b = c(0.69, 0.71, 0.71, 0.71, 0.69)-0.4)
  df2 <- data.frame(a = c(1, 1,2, 2), b = c(0.25, 0.27, 0.27, 0.25)-0.075)
  df3 <- data.frame(a = c(2, 2, 3, 3), b = c(0.25, 0.27, 0.27, 0.25)-0.2)
  
  pdf(file="bivalve_boxplots_unconstrained.pdf", width=5, height=5)
  pp + 

    #theme_clean() + geom_jitter(data=data.frame(size=log(pglsdata[,c(5)]),habitat=pglsdata[,c(3)]), width=0.1)
    theme_classic() + geom_point(color='black', fill='black',
                                 shape = 21,
                                 size = 1.5,
                                 #aes(fill = as.character(pglsdata$pch)),
                                 data = data.frame(r2t.log.unconstrained = pglsdata$r2t.log.unconstrained, habitat = pglsdata$habitat),
                                 show.legend = FALSE,
                                 position = sdamr::position_jitternudge(jitter.width = 0.2, nudge.x = -0.175)
    ) +
    scale_fill_manual(values = c(
      #"21" = scales::alpha("black", 0.9),
      #"23" = scales::alpha("white", 0.9),
      "OF" = "#007AC1",
      'Vent' = "#00BCDF",
      "Seep" = "#CAE3FC"
    ))
  
  dev.off()
}


# #middle 60% of the data
# #constrained
# anova.data.constrained
# anova.data.constrained$habitat<-ordered(anova.data.constrained$habitat, levels=c('OF', 'Vent', 'Seep'))
# phyl.aov.constrained.outlier
# {
#   pp <- ggplot(anova.data.constrained, aes(habitat, constrained)) + geom_boxplot() #+
#   #scale_fill_manual(breaks = habitat,
#   #                values = c("green", "black", "black"))
#   
#   df1 <- data.frame(a = c(1, 1:3,3), b = c(0.69, 0.71, 0.71, 0.71, 0.69)-0.4)
#   df2 <- data.frame(a = c(1, 1,2, 2), b = c(0.25, 0.27, 0.27, 0.25)-0.075)
#   df3 <- data.frame(a = c(2, 2, 3, 3), b = c(0.25, 0.27, 0.27, 0.25)-0.2)
#   
#   pdf(file="bivalve_boxplots_constrained_no_outliers.pdf", width=5, height=5)
#   pp + geom_line(data = df1, aes(x = a, y = b)) + 
#     annotate("text", x = 2, y = 0.33, label = "0.0003", size = 4) +
#     geom_line(data = df2, aes(x = a, y = b)) + 
#     annotate("text", x = 1.5, y = 0.22, label = "0.0003", size = 4) +
#     geom_line(data = df3, aes(x = a, y = b)) + 
#     annotate("text", x = 2.5, y = 0.1, label = "0.1788", size = 4) +
#     theme_clean()
#   
#   dev.off()
# }
# 
# #unconstrained
# #anova.data.unconstrained
# anova.data.unconstrained$habitat<-ordered(anova.data.unconstrained$habitat, levels=c('OF', 'Vent', 'Seep'))
# phyl.aov.unconstrained.outlier
# {
#   pp <- ggplot(anova.data.unconstrained, aes(habitat, unconstrained)) + geom_boxplot() #+
#   #scale_fill_manual(breaks = habitat,
#   #                values = c("green", "black", "black"))
#   
#   df1 <- data.frame(a = c(1, 1:3,3), b = c(0.69, 0.71, 0.71, 0.71, 0.69)-0.4)
#   df2 <- data.frame(a = c(1, 1,2, 2), b = c(0.25, 0.27, 0.27, 0.25)-0.02)
#   df3 <- data.frame(a = c(2, 2, 3, 3), b = c(0.25, 0.27, 0.27, 0.25)-0.2)
#   
#   pdf(file="bivalve_boxplots_unconstrained-no_outliers.pdf", width=5, height=5)
#   pp + geom_line(data = df1, aes(x = a, y = b)) + 
#     annotate("text", x = 2, y = 0.33, label = "0.0012", size = 4) +
#     geom_line(data = df2, aes(x = a, y = b)) + 
#     annotate("text", x = 1.5, y = 0.27, label = "0.0012", size = 4) +
#     geom_line(data = df3, aes(x = a, y = b)) + 
#     annotate("text", x = 2.5, y = 0.1, label = "0.6490", size = 4) +
#     theme_clean()
#   
#   dev.off()
# }


#size
#boxplot(size~habitat, data=brmsdata)
phyl.aov.size<-phylANOVA(tree=prunetree.shallow.time, x=setNames(brmsdata$habitat, rownames(brmsdata)), y= setNames(brmsdata$size, rownames(brmsdata)))
brmsdata$habitat<-factor(brmsdata$habitat, levels=c("OF", "Vent", "Seep"))
# 
# > phyl.aov.size
# ANOVA table: Phylogenetic ANOVA
# 
# Response: y
# Sum Sq   Mean Sq    F value Pr(>F)
# x        89.72147 44.860735 105.470669  0.001
# Residual 40.83250  0.425338                  
# 
# P-value based on simulation.
# ---------
#   
#   Pairwise posthoc test using method = "holm"
# 
# Pairwise t-values:
#   OF       Seep       Vent
# OF    0.00000 -11.522380 -12.335450
# Seep 11.52238   0.000000  -1.759585
# Vent 12.33545   1.759585   0.000000
# 
# Pairwise corrected P-values:
#   OF  Seep  Vent
# OF   1.000 0.003 0.003
# Seep 0.003 1.000 0.353
# Vent 0.003 0.353 1.000
# ---------

{
  pp <-
    ggplot(brmsdata, aes(habitat, size)) + geom_boxplot(
      aes(fill=habitat),
      outlier.shape = NA,
      width = 0.35,
      position = position_nudge(x = 0.175),
      show.legend = FALSE
    )
  df1 <- data.frame(a = c(1, 1:3,3), b = c(0.69-0.1, 0.71, 0.71, 0.71, 0.69-0.1)+7.5)
  df2 <- data.frame(a = c(1, 1,2, 2), b = c(0.25-0.1, 0.27, 0.27, 0.25-0.1)+7)
  df3 <- data.frame(a = c(2, 2, 3, 3), b = c(0.25-0.1, 0.27, 0.27, 0.25-0.1)+6.5)
  
  pdf(file="bivalve_boxplots_size_habitat.pdf", width=5, height=5)
  pp + 
    geom_line(data = df1, aes(x = a, y = b)) + 
    annotate("text", x = 2, y = 8.5, label = "0.003", size = 4) +
    geom_line(data = df2, aes(x = a, y = b)) + 
    annotate("text", x = 1.5, y = 7.5, label = "0.003", size = 4) +
    geom_line(data = df3, aes(x = a, y = b)) + 
    annotate("text", x = 2.5, y = 7, label = "0.348", size = 4) +
    #theme_clean() + geom_jitter(data=data.frame(size=log(pglsdata[,c(5)]),habitat=pglsdata[,c(3)]), width=0.1)
    theme_classic() + geom_point(
      shape = 21,
      size = 1.5,
      aes(fill = as.character(pglsdata$pch)),
      data = data.frame(size = brmsdata$size, habitat = brmsdata$habitat),
      show.legend = FALSE,
      position = sdamr::position_jitternudge(jitter.width = 0.2, nudge.x = -0.175)
    ) +
    scale_fill_manual(values = c(
      "21" = scales::alpha("black", 0.9),
      "23" = scales::alpha("white", 0.9),
      "OF" = "#007AC1",
      'Vent' = "#00BCDF",
      "Seep" = "#CAE3FC"
    ))
  
  dev.off()
}

# {
#   pp <- ggplot(brmsdata, aes(habitat, size)) + geom_boxplot() #+
#   #scale_fill_manual(breaks = habitat,
#   #                values = c("green", "black", "black"))
#   
#   df1 <- data.frame(a = c(1, 1:3,3), b = c(0.69-0.1, 0.71, 0.71, 0.71, 0.69-0.1)+7.5)
#   df2 <- data.frame(a = c(1, 1,2, 2), b = c(0.25-0.1, 0.27, 0.27, 0.25-0.1)+7)
#   df3 <- data.frame(a = c(2, 2, 3, 3), b = c(0.25-0.1, 0.27, 0.27, 0.25-0.1)+6.5)
#   
#   pdf(file="bivalve_boxplots_size_habitat.pdf", width=5, height=5)
#   pp + geom_line(data = df1, aes(x = a, y = b)) + 
#     annotate("text", x = 2, y = 8.5, label = "0.003", size = 4) +
#     geom_line(data = df2, aes(x = a, y = b)) + 
#     annotate("text", x = 1.5, y = 7.5, label = "0.003", size = 4) +
#     geom_line(data = df3, aes(x = a, y = b)) + 
#     annotate("text", x = 2.5, y = 7, label = "0.348", size = 4) +
#     theme_clean() + geom_jitter(data=data.frame(size=log(pglsdata[,c(4)]),habitat=pglsdata[,c(3)]), width=0.1)
#   
#   
#   dev.off()
# }


# save.image("~/jsb439@cornell.edu/Code/deep_sea_evolution/mytilidae_9_29.RData")
# load("~/jsb439@cornell.edu/Code/deep_sea_evolution/mytilidae_9_29.RData")
# 


# 
# intervals(ancova.test.pagel)
# summary(ancova.test.pagel)
# #experiment with gls
# require(nlme)
# ancova.test.pagel<-nlme::gls(rate~0 + habitat * size, data=brmsdata, correlation=corPagel(0.1,prunetree.shallow.time, form = ~species), na.action="na.omit", weights=varIdent(form = ~1|habitat), method = "ML",control = glsControl(opt='optim',  msVerbose=T))
# ancova.test2.pagel<-gls(rate~0 + habitat + size, data=brmsdata, correlation=corPagel(0.1,prunetree.shallow.time, form = ~species), na.action="na.omit", weights=varIdent(form = ~1|habitat), method = "ML",control = glsControl(opt='optim',  msVerbose=T))
# ancova.test3.pagel<-gls(rate~0 + habitat, data=brmsdata, correlation=corPagel(0.001,prunetree.shallow.time, form = ~species), na.action="na.omit", weights=varIdent(form = ~1|habitat), method = "ML", control = glsControl(opt='optim',  msVerbose=T))
# ancova.test4.pagel<-gls(rate~0 +  size, data=brmsdata, correlation=corPagel(0.5,prunetree.shallow.time, form = ~species), na.action="na.omit", method = "ML")
# 
# ancova.test.pagel<-gls(rate~0 + habitat * size, data=brmsdata, correlation=corPagel(0.1,prunetree.shallow.time, form = ~species), na.action="na.omit")
# ancova.test2.pagel<-gls(rate~0 + habitat + size, data=brmsdata, correlation=corPagel(0.1,prunetree.shallow.time, form = ~species), na.action="na.omit")
# ancova.test3.pagel<-gls(rate~0 + habitat, data=brmsdata, correlation=corPagel(0.1,prunetree.shallow.time, form = ~species), na.action="na.omit")
# ancova.test4.pagel<-gls(rate~0 + size, data=brmsdata, correlation=corPagel(0.1,prunetree.shallow.time, form = ~species), na.action="na.omit")
# 
# 
# prunetree.shallow.time.mod<-prunetree.shallow.time
# prunetree.shallow.time.mod$edge.length <- prunetree.shallow.time.mod$edge.length / 10
# ancova.test.ou<-gls(rate~0 + habitat * size, data=brmsdata, correlation=corMartins(1,prunetree.shallow.time.mod, form = ~species), na.action="na.omit")#, method = "ML")
# ancova.test2.ou<-gls(rate~0 + habitat + size, data=brmsdata, correlation=corMartins(1,prunetree.shallow.time.mod, form = ~species), na.action="na.omit")#, method = "ML")
# ancova.test3.ou<-gls(rate~0 + habitat, data=brmsdata, correlation=corMartins(1,prunetree.shallow.time.mod, form = ~species), na.action="na.omit")#, method = "ML")
# ancova.test4.ou<-gls(rate ~  size, data=brmsdata, correlation=corMartins(1,prunetree.shallow.time.mod, form = ~species), na.action="na.omit")#, method = "ML")
# rm(ancova.test.ou)
# 
# ancova.test.bm<-gls(rate~0 + habitat * size, data=brmsdata, correlation=corBrownian(1,prunetree.shallow.time, form = ~species), na.action="na.omit")#, method = "ML")
# ancova.test2.bm<-gls(rate~0 + habitat + size, data=brmsdata, correlation=corBrownian(1,prunetree.shallow.time, form = ~species), na.action="na.omit")#, method = "ML")
# ancova.test3.bm<-gls(rate~0 + habitat, data=brmsdata, correlation=corBrownian(1,prunetree.shallow.time, form = ~species), na.action="na.omit")#, method = "ML")
# ancova.test4.bm<-gls(rate ~  size, data=brmsdata, correlation=corBrownian(1,prunetree.shallow.time, form = ~species), na.action="na.omit")#, method = "ML")
# 
# 
# pagel<-c(AIC(ancova.test.pagel), AIC(ancova.test2.pagel), AIC(ancova.test3.pagel), AIC(ancova.test4.pagel))
# ou<-c(AIC(ancova.test.ou), AIC(ancova.test2.ou), AIC(ancova.test3.ou), AIC(ancova.test4.ou))
# bm<-c(AIC(ancova.test.bm), AIC(ancova.test2.bm), AIC(ancova.test3.bm), AIC(ancova.test4.bm))
# 
# aic.w(pagel)
# aic.w(ou)
# aic.w(bm)
# 
# summary(ancova.bm1)
# 
# 
# 

# 
# 
# 
# require(lsmeans)
# lsmeans(ancova.test3, pairwise ~ habitat)
# 
# require(multcomp)
# #http://rstudio-pubs-static.s3.amazonaws.com/13472_0daab9a778f24d3dbf38d808952455ce.html
# hyp<-glht(ancova.test3, linfct = mcp(habitat = "Tukey"))
# summary(hyp)
# 
# TukeyHSD(ancova.test3)


# 
# #trying phylogenetic ANOVA with BRMS -- this allows me to include covariates
# require(brms)
# A <- ape::vcv.phylo(prunetree.shallow.time)
# formula = bf(rate ~ 0 + habitat + size + (1|gr(species, cov = A)), sigma ~ 0 + habitat + size)
# 
# formula = bf(rate ~ 0 + habitat + (1|gr(species, cov = A)), sigma ~ 0 + habitat)
# #formula = bf(rate ~ 0 + habitat + (1|gr(species, cov = A)))
# bayes.anova<-brm(formula = formula, data2 = list(A = A), data=brmsdata, family=gaussian(), control=list(adapt_delta=0.9999, max_treedepth=12.5), cores=2, chains=4, iter=1000)
# 
# 
# #
# #https://bookdown.org/ajkurz/Statistical_Rethinking_recoded/missing-data-and-other-opportunities.html#missing-data
# formula = bf(r2t.log ~ 0 + habitat + mi(size.log) + (1|gr(species, cov = A)), sigma ~ 0 + habitat + mi(size.log)) + bf(size.log | mi() ~ 1) + set_rescor(FALSE)
# formula = bf(r2t.log ~ 0 + habitat + mi(size.log) + 1|gr(species, cov = A)) + bf(size.log | mi() ~ 1) + set_rescor(FALSE)
# 
# bayes.ancova1<-brm(formula = formula, data2 = list(A = A), data=pglsdata, family=gaussian(), control=list(adapt_delta=0.9999, max_treedepth=10), cores=3, chains=3, iter=4000)
# 
# plot(bayes.ancova1)
# plot(conditional_effects(bayes.ancova1))
# 

## checking variances of bootstrap trees
fit<-lm(log(compute_summary_stats(CO1_ML.constrained.boottrees)$Mean)~log(compute_summary_stats(CO1_ML.constrained)$Mean))
plot(log(compute_summary_stats(CO1_ML.constrained.boottrees)$Mean)~log(compute_summary_stats(CO1_ML.constrained)$Mean))

fit<-lm(log(compute_summary_stats(CO1_ML.unconstrained.boottrees)$Mean)~log(compute_summary_stats(CO1_ML.unconstrained)$Mean))
plot(log(compute_summary_stats(CO1_ML.unconstrained.boottrees)$Mean)~log(compute_summary_stats(CO1_ML.unconstrained)$Mean))
summary(fit)

median(compute_summary_stats(CO1_ML.constrained.boottrees)$CV)

